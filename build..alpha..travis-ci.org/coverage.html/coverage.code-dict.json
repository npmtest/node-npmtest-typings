{"/home/travis/build/npmtest/node-npmtest-typings/test.js":"/* istanbul instrument in package npmtest_typings */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-typings/lib.npmtest_typings.js":"/* istanbul instrument in package npmtest_typings */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_typings = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_typings = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-typings/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-typings && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_typings */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_typings\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_typings.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_typings.rollup.js'] =\n            local.assetsDict['/assets.npmtest_typings.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_typings.__dirname + '/lib.npmtest_typings.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-typings/node_modules/typings/dist/bin.js":"#!/usr/bin/env node\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar minimist = require(\"minimist\");\nvar wordwrap = require(\"wordwrap\");\nvar hasUnicode = require(\"has-unicode\");\nvar path_1 = require(\"path\");\nvar chalk = require(\"chalk\");\nvar updateNotifier = require(\"update-notifier\");\nvar extend = require(\"xtend\");\nvar events_1 = require(\"events\");\nvar cli_1 = require(\"./support/cli\");\nvar aliases_1 = require(\"./aliases\");\nvar pkg = require('../package.json');\nvar unicodeConfig = process.env['TYPINGS_CONFIG_UNICODE'] || process.env['NPM_CONFIG_UNICODE'];\nvar argv = minimist(process.argv.slice(2), {\n    boolean: ['version', 'save', 'saveDev', 'savePeer', 'global', 'verbose', 'production', 'unicode'],\n    string: ['cwd', 'out', 'name', 'source', 'offset', 'limit', 'sort', 'loglevel'],\n    alias: {\n        global: ['G'],\n        version: ['v'],\n        save: ['S'],\n        saveDev: ['save-dev', 'D'],\n        savePeer: ['savePeer', 'P'],\n        verbose: ['V'],\n        out: ['o'],\n        help: ['h']\n    },\n    default: {\n        unicode: unicodeConfig ? isTrue(unicodeConfig) : hasUnicode(),\n        production: process.env['NODE_ENV'] === 'production'\n    }\n});\nfunction isTrue(value) {\n    return value === '1' || value === 'true';\n}\nvar cwd = argv.cwd ? path_1.resolve(argv.cwd) : process.cwd();\nvar emitter = new events_1.EventEmitter();\nvar args = extend(argv, { emitter: emitter, cwd: cwd });\nif (argv.loglevel) {\n    cli_1.setLoglevel(argv.loglevel);\n}\nupdateNotifier({ pkg: pkg }).notify();\nexec(args);\nemitter.on('enoent', function (_a) {\n    var path = _a.path;\n    cli_1.logWarning(\"Path \\\"\" + path + \"\\\" is missing\", 'enoent');\n});\nemitter.on('hastypings', function (_a) {\n    var name = _a.name, typings = _a.typings;\n    cli_1.logWarning(\"Typings for \\\"\" + name + \"\\\" already exist in \\\"\" + path_1.relative(cwd, typings) + \"\\\". You should \" +\n        \"let TypeScript resolve the packaged typings and uninstall the copy installed by Typings\", 'hastypings');\n});\nemitter.on('postmessage', function (_a) {\n    var message = _a.message, name = _a.name;\n    cli_1.logInfo(name + \": \" + message, 'postmessage');\n});\nemitter.on('badlocation', function (_a) {\n    var raw = _a.raw;\n    cli_1.logWarning(\"\\\"\" + raw + \"\\\" is mutable and may change, consider specifying a commit hash\", 'badlocation');\n});\nemitter.on('deprecated', function (_a) {\n    var date = _a.date, raw = _a.raw, parent = _a.parent;\n    if (parent == null || parent.raw == null) {\n        cli_1.logWarning(date.toLocaleDateString() + \": \\\"\" + raw + \"\\\" is deprecated (updated, replaced or removed)\", 'deprecated');\n    }\n});\nemitter.on('prune', function (_a) {\n    var name = _a.name, global = _a.global, resolution = _a.resolution;\n    var suffix = chalk.gray(\" (\" + resolution + \")\" + (global ? ' (global)' : ''));\n    cli_1.logInfo(\"\" + name + suffix, 'prune');\n});\nemitter.on('resolve', function (_a) {\n    var src = _a.src, name = _a.name;\n    cli_1.setStatus(\"Resolving \\\"\" + name + \"\\\" from \\\"\" + src + \"\\\"\");\n});\nemitter.on('resolved', function (_a) {\n    var name = _a.name;\n    cli_1.setStatus(\"Resolved \\\"\" + name + \"\\\"\");\n});\nemitter.on('compiledependency', function (_a) {\n    var name = _a.name;\n    cli_1.setStatus(\"Compiling \\\"\" + name + \"\\\"\");\n});\nfunction exec(options) {\n    if (options._.length) {\n        var command = aliases_1.aliases[options._[0]];\n        var args_1 = options._.slice(1);\n        if (command != null) {\n            if (options.help) {\n                return console.log(command.help());\n            }\n            return cli_1.handle(command.exec(args_1, options), options);\n        }\n    }\n    else if (options.version) {\n        console.log(pkg.version);\n        return;\n    }\n    var wrap = wordwrap(4, 80);\n    console.log(\"\\nUsage: typings <command>\\n\\nCommands:\\n\" + wrap(Object.keys(aliases_1.aliases).sort().join(', ')) + \"\\n\\ntypings <command> -h    Get help for <command>\\ntypings <command> -V    Enable verbose logging\\n\\ntypings --version       Print the CLI version\\n  [--loglevel] <level>  Set the log level (\\\"debug\\\", info\\\", \\\"warn\\\", \\\"error\\\" or \\\"silent\\\")\\n\\ntypings@\" + pkg.version + \" \" + path_1.join(__dirname, '..') + \"\\n\");\n}\n//# sourceMappingURL=bin.js.map","/home/travis/build/npmtest/node-npmtest-typings/node_modules/typings/dist/support/cli.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar chalk = require(\"chalk\");\nvar archy = require(\"archy\");\nvar listify = require(\"listify\");\nvar logUpdate = require(\"log-update\");\nvar elegantSpinner = require(\"elegant-spinner\");\nvar truncate = require(\"cli-truncate\");\nvar os = require(\"os\");\nvar promise_finally_1 = require(\"promise-finally\");\nvar pkg = require('../../package.json');\nvar statusFrame;\nvar statusTimeout;\nvar statusMessage;\nfunction log(message) {\n    logUpdate.clear();\n    console.error(message);\n    render();\n}\nexports.log = log;\nfunction formatLine(color, type, line, prefix) {\n    return chalk.bgBlack.white('typings') + \" \" + color(type) + \" \" + (prefix ? chalk.magenta(prefix + \" \") : '') + line;\n}\nvar loglevels = {\n    debug: 0,\n    info: 1,\n    warn: 2,\n    error: 3,\n    silent: 4\n};\nvar loglevel = loglevels['info'];\nfunction setLoglevel(level) {\n    if (!loglevels.hasOwnProperty(level)) {\n        logError(\"invalid log level (options are \" + listify(Object.keys(loglevels)) + \")\");\n        return;\n    }\n    return (loglevel = loglevels[level]);\n}\nexports.setLoglevel = setLoglevel;\nfunction logInfo(message, prefix) {\n    if (loglevel > loglevels['info']) {\n        return;\n    }\n    var output = message.split(/\\r?\\n/g).map(function (line) {\n        return formatLine(chalk.bgBlack.cyan, 'INFO', line, prefix);\n    }).join('\\n');\n    log(output);\n}\nexports.logInfo = logInfo;\nfunction logWarning(message, prefix) {\n    if (loglevel > loglevels['warn']) {\n        return;\n    }\n    var output = message.split(/\\r?\\n/g).map(function (line) {\n        return formatLine(chalk.bgYellow.black, 'WARN', line, prefix);\n    }).join('\\n');\n    log(output);\n}\nexports.logWarning = logWarning;\nfunction logError(message, prefix) {\n    if (loglevel > loglevels['error']) {\n        return;\n    }\n    var output = message.split(/\\r?\\n/g).map(function (line) {\n        return formatLine(chalk.bgBlack.red, 'ERR!', line, prefix);\n    }).join('\\n');\n    log(output);\n}\nexports.logError = logError;\nfunction setStatus(message) {\n    statusMessage = message;\n}\nexports.setStatus = setStatus;\nfunction render() {\n    clearInterval(statusTimeout);\n    if (statusFrame && process.stdout.isTTY) {\n        var status = chalk.cyan(statusFrame());\n        if (statusMessage) {\n            status += \" \" + statusMessage;\n        }\n        logUpdate(truncate(status, process.stdout.columns));\n        statusTimeout = setTimeout(render, 50);\n    }\n}\nexports.render = render;\nfunction startSpinner() {\n    statusFrame = elegantSpinner();\n    render();\n}\nexports.startSpinner = startSpinner;\nfunction stopSpinner() {\n    clearTimeout(statusTimeout);\n    statusFrame = undefined;\n    statusTimeout = undefined;\n    statusMessage = undefined;\n    logUpdate.clear();\n    logUpdate.done();\n}\nexports.stopSpinner = stopSpinner;\nfunction spinner(promise) {\n    startSpinner();\n    return promise_finally_1.default(Promise.resolve(promise), stopSpinner);\n}\nexports.spinner = spinner;\nfunction handle(promise, options) {\n    return Promise.resolve(promise).catch(function (err) { return handleError(err, options); });\n}\nexports.handle = handle;\nfunction handleError(error, options) {\n    var cause = error.cause;\n    logError(error.message, 'message');\n    while (cause) {\n        logError(cause.message, 'caused by');\n        cause = cause.cause;\n    }\n    if (options.verbose && error.stack) {\n        logError('');\n        logError(error.stack, 'stack');\n    }\n    logError('');\n    logError(process.cwd(), 'cwd');\n    logError(os.type() + \" \" + os.release(), 'system');\n    logError(process.argv.map(function (arg) { return JSON.stringify(arg); }).join(' '), 'command');\n    logError(process.version, 'node -v');\n    logError(pkg.version, \"typings -v\");\n    if (error.code) {\n        logError(error.code, 'code');\n    }\n    logError('');\n    logError('If you need help, you may report this error at:');\n    logError(\"  <https://github.com/typings/typings/issues>\");\n    process.exit(1);\n}\nexports.handleError = handleError;\nfunction toDependencyName(name, node, suffix) {\n    var fullname = node.version ? name + \"@\" + node.version : name;\n    return suffix ? fullname + \" \" + suffix : fullname;\n}\nfunction archifyDependencyTree(options) {\n    var result = {\n        label: options.name ? toDependencyName(options.name, options.tree) : '',\n        nodes: []\n    };\n    function children(nodes, dependencies, suffix) {\n        for (var _i = 0, _a = Object.keys(dependencies).sort(); _i < _a.length; _i++) {\n            var name = _a[_i];\n            var tree_1 = dependencies[name];\n            nodes.push(traverse({\n                label: toDependencyName(name, tree_1, suffix),\n                nodes: []\n            }, tree_1));\n        }\n    }\n    function traverse(result, tree) {\n        var nodes = result.nodes;\n        children(nodes, tree.dependencies);\n        children(nodes, tree.devDependencies, chalk.gray('(dev)'));\n        children(nodes, tree.peerDependencies, chalk.gray('(peer)'));\n        children(nodes, tree.globalDependencies, chalk.gray('(global)'));\n        children(nodes, tree.globalDevDependencies, chalk.gray('(global dev)'));\n        return result;\n    }\n    var tree = traverse(result, options.tree);\n    return archy(tree, '', { unicode: options.unicode });\n}\nexports.archifyDependencyTree = archifyDependencyTree;\n//# sourceMappingURL=cli.js.map","/home/travis/build/npmtest/node-npmtest-typings/node_modules/typings/dist/aliases.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar bundle = require(\"./bin-bundle\");\nvar init = require(\"./bin-init\");\nvar uninstall = require(\"./bin-uninstall\");\nvar install = require(\"./bin-install\");\nvar list = require(\"./bin-list\");\nvar search = require(\"./bin-search\");\nvar open = require(\"./bin-open\");\nvar view = require(\"./bin-view\");\nvar prune = require(\"./bin-prune\");\nexports.aliases = {\n    i: install,\n    in: install,\n    install: install,\n    r: uninstall,\n    rm: uninstall,\n    un: uninstall,\n    remove: uninstall,\n    uninstall: uninstall,\n    init: init,\n    ls: list,\n    ll: list,\n    la: list,\n    list: list,\n    bundle: bundle,\n    search: search,\n    open: open,\n    view: view,\n    info: view,\n    prune: prune\n};\n//# sourceMappingURL=aliases.js.map","/home/travis/build/npmtest/node-npmtest-typings/node_modules/typings/dist/bin-bundle.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar typings_core_1 = require(\"typings-core\");\nvar cli_1 = require(\"./support/cli\");\nfunction help() {\n    return \"\\ntypings bundle --out <filepath>\\n\\nOptions:\\n  [--out|-o] <filepath>  The bundled output file path\\n  [--global|-G]          Bundle as a global definition\\n\";\n}\nexports.help = help;\nfunction exec(args, options) {\n    return cli_1.spinner(typings_core_1.bundle(options));\n}\nexports.exec = exec;\n//# sourceMappingURL=bin-bundle.js.map","/home/travis/build/npmtest/node-npmtest-typings/node_modules/typings-core/dist/typings.js":"\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(require(\"./install\"));\n__export(require(\"./uninstall\"));\n__export(require(\"./init\"));\n__export(require(\"./bundle\"));\n__export(require(\"./search\"));\n__export(require(\"./list\"));\n__export(require(\"./open\"));\n__export(require(\"./view\"));\n__export(require(\"./prune\"));\nexports.VERSION = require('../package.json').version;\n//# sourceMappingURL=typings.js.map","/home/travis/build/npmtest/node-npmtest-typings/node_modules/typings-core/dist/install.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = require(\"xtend\");\nvar path_1 = require(\"path\");\nvar events_1 = require(\"events\");\nvar dependencies_1 = require(\"./lib/dependencies\");\nvar compile_1 = require(\"./lib/compile\");\nvar find_1 = require(\"./utils/find\");\nvar fs_1 = require(\"./utils/fs\");\nvar path_2 = require(\"./utils/path\");\nvar parse_1 = require(\"./utils/parse\");\nexports.parseDependency = parse_1.parseDependency;\nexports.expandRegistry = parse_1.expandRegistry;\nexports.parseDependencyExpression = parse_1.parseDependencyExpression;\nexports.buildDependencyExpression = parse_1.buildDependencyExpression;\nvar config_1 = require(\"./utils/config\");\nfunction install(options) {\n    var cwd = options.cwd, production = options.production;\n    var emitter = options.emitter || new events_1.EventEmitter();\n    return find_1.findConfigFile(cwd)\n        .then(function (configFile) {\n        var cwd = path_1.dirname(configFile);\n        return fs_1.readConfig(configFile)\n            .then(function (config) {\n            var resolutions = path_2.normalizeResolutions(config.resolution, options);\n            return dependencies_1.resolveTypeDependencies({\n                cwd: cwd,\n                emitter: emitter,\n                global: true,\n                peer: true,\n                dev: !production\n            })\n                .then(function (tree) {\n                var cwd = path_1.dirname(tree.src);\n                var queue = [];\n                function addToQueue(deps, global) {\n                    for (var _i = 0, _a = Object.keys(deps); _i < _a.length; _i++) {\n                        var name = _a[_i];\n                        var tree_1 = deps[name];\n                        queue.push(compile_1.compile(tree_1, Object.keys(resolutions), {\n                            cwd: cwd,\n                            name: name,\n                            global: global,\n                            emitter: emitter,\n                            meta: true\n                        }));\n                    }\n                }\n                addToQueue(tree.dependencies, false);\n                addToQueue(tree.devDependencies, false);\n                addToQueue(tree.peerDependencies, false);\n                addToQueue(tree.globalDependencies, true);\n                addToQueue(tree.globalDevDependencies, true);\n                return Promise.all(queue)\n                    .then(function (results) {\n                    return Promise.all(results.map(function (x) { return writeResult(x, { resolutions: resolutions }); }))\n                        .then(function () { return writeBundle(results, { resolutions: resolutions }); })\n                        .then(function () { return ({ tree: tree }); });\n                });\n            });\n        });\n    }, function () {\n        emitter.emit('enoent', { path: path_1.join(cwd, config_1.CONFIG_FILE) });\n        return { tree: extend(dependencies_1.DEFAULT_DEPENDENCY) };\n    });\n}\nexports.install = install;\nfunction installDependencyRaw(raw, options) {\n    return installDependenciesRaw([raw], options).then(function (x) { return x[0]; });\n}\nexports.installDependencyRaw = installDependencyRaw;\nfunction installDependenciesRaw(raw, options) {\n    return new Promise(function (resolve) {\n        var expressions = raw.map(function (x) { return parse_1.parseDependencyExpression(x, options); });\n        return resolve(installDependencies(expressions, options));\n    });\n}\nexports.installDependenciesRaw = installDependenciesRaw;\nfunction installDependency(expression, options) {\n    return installDependencies([expression], options).then(function (x) { return x[0]; });\n}\nexports.installDependency = installDependency;\nfunction installDependencies(expressions, options) {\n    var emitter = options.emitter || new events_1.EventEmitter();\n    return find_1.findConfigFile(options.cwd)\n        .then(function (configFile) {\n        var cwd = path_1.dirname(configFile);\n        return fs_1.readConfig(configFile)\n            .then(function (config) {\n            var resolutions = path_2.normalizeResolutions(config.resolution, options);\n            return extend(options, { resolutions: resolutions, cwd: cwd, emitter: emitter });\n        });\n    }, function () {\n        var resolutions = path_2.normalizeResolutions(undefined, options);\n        return extend(options, { emitter: emitter, resolutions: resolutions });\n    })\n        .then(function (options) {\n        return Promise.all(expressions.map(function (x) { return compileDependency(x, options); }))\n            .then(function (results) {\n            return Promise.all(results.map(function (x) { return writeResult(x, options); }))\n                .then(function () { return writeBundle(results, options); })\n                .then(function () { return writeToConfig(results, options); })\n                .then(function () { return results.map(function (_a) {\n                var name = _a.name, tree = _a.tree;\n                return ({ name: name, tree: tree });\n            }); });\n        });\n    });\n}\nexports.installDependencies = installDependencies;\nfunction compileDependency(expression, options) {\n    var dependency = parse_1.parseDependency(expression.location);\n    var cwd = options.cwd, global = options.global, resolutions = options.resolutions;\n    var emitter = options.emitter || new events_1.EventEmitter();\n    var expName = expression.name || dependency.meta.name;\n    return checkTypings(dependency, options)\n        .then(function () {\n        return dependencies_1.resolveDependency(dependency, { cwd: cwd, emitter: emitter, name: expName, dev: false, peer: false, global: false });\n    })\n        .then(function (tree) {\n        var name = expName || tree.name;\n        if (!name) {\n            return Promise.reject(new TypeError(\"Unable to install dependency from \\\"\" + tree.raw + \"\\\" without a name\"));\n        }\n        if (tree.postmessage) {\n            emitter.emit('postmessage', { name: name, message: tree.postmessage });\n        }\n        return compile_1.compile(tree, Object.keys(resolutions), {\n            cwd: cwd,\n            name: name,\n            global: global,\n            emitter: emitter,\n            meta: true\n        });\n    });\n}\nfunction writeToConfig(results, options) {\n    if (options.save || options.saveDev || options.savePeer) {\n        return fs_1.transformConfig(options.cwd, function (config) {\n            for (var _i = 0, results_1 = results; _i < results_1.length; _i++) {\n                var _a = results_1[_i], name = _a.name, tree = _a.tree;\n                var raw = tree.raw;\n                if (options.save) {\n                    if (options.global) {\n                        config.globalDependencies = extend(config.globalDependencies, (_b = {}, _b[name] = raw, _b));\n                    }\n                    else {\n                        config.dependencies = extend(config.dependencies, (_c = {}, _c[name] = raw, _c));\n                    }\n                }\n                else if (options.saveDev) {\n                    if (options.global) {\n                        config.globalDevDependencies = extend(config.globalDevDependencies, (_d = {}, _d[name] = raw, _d));\n                    }\n                    else {\n                        config.devDependencies = extend(config.devDependencies, (_e = {}, _e[name] = raw, _e));\n                    }\n                }\n                else if (options.savePeer) {\n                    if (options.global) {\n                        throw new TypeError('Unable to use `savePeer` with the `global` flag');\n                    }\n                    else {\n                        config.peerDependencies = extend(config.peerDependencies, (_f = {}, _f[name] = raw, _f));\n                    }\n                }\n            }\n            return config;\n            var _b, _c, _d, _e, _f;\n        });\n    }\n    return Promise.resolve();\n}\nfunction writeBundle(results, options) {\n    var resolutions = options.resolutions;\n    return Promise.all(Object.keys(resolutions).map(function (resolution) {\n        var path = resolutions[resolution];\n        var paths = results.map(function (_a) {\n            var name = _a.name, global = _a.global;\n            return path_2.getDependencyPath({ path: path, name: name, global: global }).definition;\n        });\n        return fs_1.mkdirp(path)\n            .then(function () {\n            var bundle = path_2.getDefinitionPath(path);\n            if (paths.length === 0) {\n                return fs_1.touch(bundle);\n            }\n            return fs_1.transformDtsFile(bundle, function (x) { return x.concat(paths); });\n        });\n    }));\n}\nfunction writeResult(result, options) {\n    var name = result.name, global = result.global, tree = result.tree, results = result.results;\n    var resolutions = options.resolutions;\n    return Promise.all(Object.keys(resolutions).map(function (resolution) {\n        var path = resolutions[resolution];\n        var contents = results[resolution];\n        var _a = path_2.getDependencyPath({ name: name, global: global, path: path }), directory = _a.directory, config = _a.config, definition = _a.definition;\n        return fs_1.mkdirp(directory)\n            .then(function () {\n            return Promise.all([\n                fs_1.writeJson(config, { resolution: resolution, tree: fs_1.treeToJson(tree) }),\n                fs_1.writeFile(definition, contents)\n            ]);\n        });\n    }));\n}\nfunction checkTypings(dependency, options) {\n    var type = dependency.type, meta = dependency.meta;\n    if (type === 'registry' && meta.source === 'npm') {\n        return find_1.findUp(options.cwd, path_1.join('node_modules', meta.name, 'package.json'))\n            .then(function (path) {\n            return fs_1.readJson(path)\n                .then(function (packageJson) {\n                if (packageJson && typeof packageJson.typings === 'string') {\n                    options.emitter.emit('hastypings', {\n                        name: meta.name,\n                        source: meta.source,\n                        path: path,\n                        typings: path_2.resolveFrom(path, packageJson.typings)\n                    });\n                }\n            });\n        })\n            .catch(function () { return undefined; });\n    }\n    return Promise.resolve();\n}\n//# sourceMappingURL=install.js.map","/home/travis/build/npmtest/node-npmtest-typings/node_modules/typings-core/dist/lib/dependencies.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = require(\"xtend\");\nvar listify = require(\"listify\");\nvar invariant = require(\"invariant\");\nvar zipObject = require(\"zip-object\");\nvar path_1 = require(\"path\");\nvar url_1 = require(\"url\");\nvar jspm_config_1 = require(\"jspm-config\");\nvar fs_1 = require(\"../utils/fs\");\nvar parse_1 = require(\"../utils/parse\");\nvar find_1 = require(\"../utils/find\");\nvar path_2 = require(\"../utils/path\");\nvar config_1 = require(\"../utils/config\");\nvar search_1 = require(\"../search\");\nvar error_1 = require(\"./error\");\nexports.DEFAULT_DEPENDENCY = {\n    src: undefined,\n    raw: undefined,\n    main: undefined,\n    browser: undefined,\n    typings: undefined,\n    browserTypings: undefined,\n    version: undefined,\n    files: undefined,\n    global: undefined,\n    postmessage: undefined,\n    dependencies: {},\n    devDependencies: {},\n    peerDependencies: {},\n    globalDependencies: {},\n    globalDevDependencies: {}\n};\nfunction resolveAllDependencies(options) {\n    return Promise.all([\n        resolveBowerDependencies(options).catch(function () { return extend(exports.DEFAULT_DEPENDENCY); }),\n        resolveNpmDependencies(options).catch(function () { return extend(exports.DEFAULT_DEPENDENCY); }),\n        resolveJspmDependencies(options).catch(function () { return extend(exports.DEFAULT_DEPENDENCY); }),\n        resolveTypeDependencies(options).catch(function () { return extend(exports.DEFAULT_DEPENDENCY); })\n    ])\n        .then(function (trees) { return mergeDependencies.apply(void 0, [exports.DEFAULT_DEPENDENCY].concat(trees)); });\n}\nexports.resolveAllDependencies = resolveAllDependencies;\nfunction resolveDependency(dependency, options) {\n    var type = dependency.type, location = dependency.location, raw = dependency.raw, meta = dependency.meta;\n    if (type === 'registry') {\n        return resolveDependencyRegistry(dependency, options);\n    }\n    if (type === 'github' || type === 'bitbucket') {\n        if (meta.sha === 'master') {\n            options.emitter.emit('badlocation', { type: type, raw: raw, location: location });\n        }\n    }\n    return resolveDependencyInternally(type, location, raw, options);\n}\nexports.resolveDependency = resolveDependency;\nfunction resolveDependencyInternally(type, location, raw, options) {\n    if (type === 'jspm' || (type === 'npm' && options.jspmConfig)) {\n        return resolveJspmDependency(location, raw, options);\n    }\n    if (type === 'npm') {\n        return resolveNpmDependency(location, raw, options);\n    }\n    if (type === 'bower') {\n        return resolveBowerDependency(location, raw, options);\n    }\n    return resolveFileDependency(location, raw, options);\n}\nfunction resolveDependencyRegistry(dependency, options) {\n    var location = dependency.location, meta = dependency.meta;\n    return fs_1.readJsonFrom(location)\n        .then(function (entry) {\n        var _a = parse_1.parseDependency(entry.location), type = _a.type, location = _a.location;\n        var raw = \"registry:\" + meta.source + \"/\" + meta.name + \"#\" + entry.tag;\n        if (entry.deprecated) {\n            options.emitter.emit('deprecated', {\n                parent: options.parent,\n                raw: dependency.raw,\n                date: new Date(entry.deprecated)\n            });\n        }\n        return resolveDependencyInternally(type, location, raw, options);\n    }, function (error) {\n        if (error.code === 'EINVALIDSTATUS' && error.status === 404) {\n            return search_1.search({ name: meta.name })\n                .then(function (res) {\n                var message = \"Unable to find \\\"\" + meta.name + \"\\\" (\\\"\" + meta.source + \"\\\") in the registry.\";\n                if (res.total > 0) {\n                    var plur = res.total === 1 ? 'source' : 'sources';\n                    message += \"\\nHowever, we found \\\"\" + meta.name + \"\\\" for \" + res.total + \" other \" + plur + \": \";\n                    message += \"\" + listify(res.results.map(function (x) { return JSON.stringify(x.source); }));\n                    message += \"\\nYou can install these using the \\\"source\\\" option.\";\n                }\n                message += '\\nWe could use your help adding these typings to the registry: ';\n                message += 'https://github.com/typings/registry';\n                return Promise.reject(new error_1.default(message, error));\n            });\n        }\n        return Promise.reject(error);\n    });\n}\nfunction resolveNpmDependency(pkgName, raw, options) {\n    return find_1.findUp(options.cwd, path_1.join('node_modules', pkgName))\n        .then(function (modulePath) {\n        if (path_2.isDefinition(modulePath)) {\n            return resolveFileDependency(modulePath, raw, options);\n        }\n        return resolveNpmDependencyFrom(modulePath, raw, options);\n    }, function (error) {\n        return Promise.reject(resolveError(raw, error, options));\n    });\n}\nfunction resolveBowerDependency(name, raw, options) {\n    return resolveBowerComponentPath(options.cwd)\n        .then(function (bowerComponentPath) {\n        var modulePath = path_1.resolve(bowerComponentPath, name);\n        if (path_2.isDefinition(modulePath)) {\n            return resolveFileDependency(modulePath, raw, options);\n        }\n        return resolveBowerDependencyFrom(modulePath, raw, extend(options, { bowerComponentPath: bowerComponentPath }));\n    }, function (error) {\n        return Promise.reject(resolveError(raw, error, options));\n    });\n}\nfunction resolveFileDependency(location, raw, options) {\n    var name = options.name, parent = options.parent;\n    var src;\n    if (path_2.isHttp(location)) {\n        src = location;\n    }\n    else if (parent && path_2.isHttp(parent.src)) {\n        src = url_1.resolve(parent.src, location);\n    }\n    else {\n        src = path_1.resolve(options.cwd, location);\n    }\n    if (!path_2.isDefinition(src)) {\n        return resolveTypeDependencyFrom(src, raw, options);\n    }\n    options.emitter.emit('resolve', { name: name, src: src, raw: raw, parent: parent });\n    var tree = extend(exports.DEFAULT_DEPENDENCY, {\n        typings: src,\n        src: src,\n        raw: raw,\n        parent: parent\n    });\n    options.emitter.emit('resolved', { name: name, src: src, tree: tree, raw: raw, parent: parent });\n    return Promise.resolve(tree);\n}\nfunction resolveBowerDependencies(options) {\n    return find_1.findUp(options.cwd, 'bower.json')\n        .then(function (bowerJsonPath) {\n        return resolveBowerComponentPath(path_1.dirname(bowerJsonPath))\n            .then(function (bowerComponentPath) {\n            return resolveBowerDependencyFrom(bowerJsonPath, undefined, extend(options, { bowerComponentPath: bowerComponentPath }));\n        });\n    }, function (cause) {\n        return Promise.reject(new error_1.default(\"Unable to resolve Bower dependencies\", cause));\n    });\n}\nexports.resolveBowerDependencies = resolveBowerDependencies;\nfunction resolveBowerDependencyFrom(src, raw, options) {\n    var name = options.name, parent = options.parent;\n    checkCircularDependency(parent, src);\n    options.emitter.emit('resolve', { name: name, src: src, raw: raw, parent: parent });\n    return fs_1.readJson(src)\n        .then(function (bowerJson) {\n        if (bowerJson === void 0) { bowerJson = {}; }\n        var tree = extend(exports.DEFAULT_DEPENDENCY, {\n            name: bowerJson.name,\n            version: bowerJson.version,\n            main: bowerJson.main,\n            browser: bowerJson.browser,\n            typings: bowerJson.typings,\n            browserTypings: bowerJson.browserTypings,\n            src: src,\n            raw: raw,\n            parent: parent\n        });\n        var dependencyMap = extend(bowerJson.dependencies);\n        var devDependencyMap = extend(options.dev ? bowerJson.devDependencies : {});\n        var dependencyOptions = extend(options, { parent: tree });\n        options.emitter.emit('resolved', { name: name || tree.name, src: src, tree: tree, raw: raw, parent: parent });\n        return Promise.all([\n            resolveBowerDependencyMap(dependencyMap, dependencyOptions),\n            resolveBowerDependencyMap(devDependencyMap, dependencyOptions),\n            maybeResolveTypeDependencyFrom(path_1.join(src, '..', config_1.CONFIG_FILE), raw, options)\n        ])\n            .then(function (_a) {\n            var dependencies = _a[0], devDependencies = _a[1], typedPackage = _a[2];\n            tree.dependencies = dependencies;\n            tree.devDependencies = devDependencies;\n            return mergeDependencies(tree, typedPackage);\n        });\n    }, function (error) {\n        return Promise.reject(resolveError(raw, error, options));\n    });\n}\nfunction resolveBowerComponentPath(path) {\n    return fs_1.readJson(path_1.resolve(path, '.bowerrc'))\n        .then(function (bowerrc) {\n        if (bowerrc === void 0) { bowerrc = {}; }\n        return path_1.resolve(path, bowerrc.directory || 'bower_components');\n    }, function () {\n        return path_1.resolve(path, 'bower_components');\n    });\n}\nfunction resolveBowerDependencyMap(dependencies, options) {\n    var keys = Object.keys(dependencies);\n    return Promise.all(keys.map(function (name) {\n        var modulePath = path_1.resolve(options.bowerComponentPath, name, 'bower.json');\n        var resolveOptions = extend(options, { name: name, dev: false, global: false, peer: false });\n        return resolveBowerDependencyFrom(modulePath, \"bower:\" + name, resolveOptions);\n    }))\n        .then(function (results) { return zipObject(keys, results); });\n}\nfunction resolveNpmDependencies(options) {\n    return find_1.findUp(options.cwd, 'package.json')\n        .then(function (packageJsonPath) {\n        return resolveNpmDependencyFrom(packageJsonPath, undefined, options);\n    }, function (cause) {\n        return Promise.reject(new error_1.default(\"Unable to resolve NPM dependencies\", cause));\n    });\n}\nexports.resolveNpmDependencies = resolveNpmDependencies;\nfunction resolveJspmDependencies(options) {\n    return find_1.findUp(options.cwd, 'package.json')\n        .then(function (packageJsonPath) {\n        var cwd = path_1.dirname(packageJsonPath);\n        return jspm_config_1.readJspmPackageJson({ cwd: cwd })\n            .then(function (packageJson) {\n            return jspm_config_1.resolveByPackageJson(packageJson, { cwd: cwd })\n                .then(function (config) {\n                var keys = Object.keys(config);\n                return Promise.all(keys.map(function (name) {\n                    var jspmConfig = config[name];\n                    return resolveJspmDependencyFrom(name, \"jspm:\" + name, extend(options, { jspmConfig: jspmConfig }));\n                }))\n                    .then(function (results) {\n                    var tree = extend(exports.DEFAULT_DEPENDENCY, {\n                        name: packageJson.name,\n                        version: packageJson.version,\n                        main: packageJson.main,\n                        browser: packageJson.browser,\n                        typings: packageJson.typings,\n                        browserTypings: packageJson.browserTypings,\n                        src: packageJsonPath,\n                        dependencies: zipObject(keys, results)\n                    });\n                    return tree;\n                });\n            });\n        });\n    });\n}\nexports.resolveJspmDependencies = resolveJspmDependencies;\nfunction resolveNpmDependencyFrom(src, raw, options) {\n    var name = options.name, parent = options.parent;\n    checkCircularDependency(parent, src);\n    options.emitter.emit('resolve', { name: name, src: src, raw: raw, parent: parent });\n    return fs_1.readJson(src)\n        .then(function (packageJson) {\n        if (packageJson === void 0) { packageJson = {}; }\n        var tree = extend(exports.DEFAULT_DEPENDENCY, {\n            name: packageJson.name,\n            version: packageJson.version,\n            main: packageJson.main,\n            browser: packageJson.browser,\n            typings: packageJson.typings,\n            browserTypings: packageJson.browserTypings,\n            src: src,\n            raw: raw,\n            parent: parent\n        });\n        var dependencyMap = extend(packageJson.dependencies);\n        var devDependencyMap = extend(options.dev ? packageJson.devDependencies : {});\n        var peerDependencyMap = extend(options.peer ? packageJson.peerDependencies : {});\n        var dependencyOptions = extend(options, { parent: tree });\n        options.emitter.emit('resolved', { name: name || tree.name, src: src, tree: tree, raw: raw, parent: parent });\n        return Promise.all([\n            resolveNpmDependencyMap(src, dependencyMap, dependencyOptions),\n            resolveNpmDependencyMap(src, devDependencyMap, dependencyOptions),\n            resolveNpmDependencyMap(src, peerDependencyMap, dependencyOptions),\n            maybeResolveTypeDependencyFrom(path_1.join(src, '..', config_1.CONFIG_FILE), raw, options)\n        ])\n            .then(function (_a) {\n            var dependencies = _a[0], devDependencies = _a[1], peerDependencies = _a[2], typedPackage = _a[3];\n            tree.dependencies = dependencies;\n            tree.devDependencies = devDependencies;\n            tree.peerDependencies = peerDependencies;\n            return mergeDependencies(tree, typedPackage);\n        });\n    }, function (error) {\n        return Promise.reject(resolveError(raw, error, options));\n    });\n}\nfunction resolveNpmDependencyMap(src, dependencies, options) {\n    var cwd = path_1.dirname(src);\n    var keys = Object.keys(dependencies);\n    return Promise.all(keys.map(function (name) {\n        var resolveOptions = extend(options, { name: name, cwd: cwd, dev: false, peer: false, global: false });\n        return resolveNpmDependency(path_1.join(name, 'package.json'), \"npm:\" + name, resolveOptions);\n    }))\n        .then(function (results) { return zipObject(keys, results); });\n}\nfunction resolveTypeDependencies(options) {\n    return find_1.findConfigFile(options.cwd)\n        .then(function (path) {\n        return resolveTypeDependencyFrom(path, undefined, options);\n    }, function (cause) {\n        return Promise.reject(new error_1.default(\"Unable to resolve Typings dependencies\", cause));\n    });\n}\nexports.resolveTypeDependencies = resolveTypeDependencies;\nfunction resolveTypeDependencyFrom(src, raw, options) {\n    var name = options.name, parent = options.parent;\n    checkCircularDependency(parent, src);\n    options.emitter.emit('resolve', { name: name, src: src, raw: raw, parent: parent });\n    return fs_1.readConfigFrom(src)\n        .then(function (config) {\n        var tree = extend(exports.DEFAULT_DEPENDENCY, {\n            name: config.name,\n            main: config.main,\n            version: config.version,\n            browser: config.browser,\n            files: Array.isArray(config.files) ? config.files : undefined,\n            global: typeof config.global === 'boolean' ? !!config.global : undefined,\n            postmessage: typeof config.postmessage === 'string' ? config.postmessage : undefined,\n            src: src,\n            raw: raw,\n            parent: parent\n        });\n        var global = options.global, dev = options.dev, peer = options.peer;\n        var dependencyMap = extend(config.dependencies);\n        var devDependencyMap = extend(dev ? config.devDependencies : {});\n        var peerDependencyMap = extend(peer ? config.peerDependencies : {});\n        var globalDependencyMap = extend(global ? config.globalDependencies : {});\n        var globalDevDependencyMap = extend(global && dev ? config.globalDevDependencies : {});\n        var dependencyOptions = extend(options, { parent: tree });\n        options.emitter.emit('resolved', { name: name || tree.name, src: src, tree: tree, raw: raw, parent: parent });\n        if (parent == null && config.globalDependencies) {\n            options.emitter.emit('globaldependencies', {\n                name: name || tree.name,\n                raw: raw,\n                dependencies: config.globalDependencies\n            });\n        }\n        return Promise.all([\n            resolveTypeDependencyMap(src, dependencyMap, dependencyOptions),\n            resolveTypeDependencyMap(src, devDependencyMap, dependencyOptions),\n            resolveTypeDependencyMap(src, peerDependencyMap, dependencyOptions),\n            resolveTypeDependencyMap(src, globalDependencyMap, dependencyOptions),\n            resolveTypeDependencyMap(src, globalDevDependencyMap, dependencyOptions)\n        ])\n            .then(function (_a) {\n            var dependencies = _a[0], devDependencies = _a[1], peerDependencies = _a[2], globalDependencies = _a[3], globalDevDependencies = _a[4];\n            tree.dependencies = dependencies;\n            tree.devDependencies = devDependencies;\n            tree.peerDependencies = peerDependencies;\n            tree.globalDependencies = globalDependencies;\n            tree.globalDevDependencies = globalDevDependencies;\n            return tree;\n        });\n    }, function (error) {\n        return Promise.reject(resolveError(raw, error, options));\n    });\n}\nfunction maybeResolveTypeDependencyFrom(src, raw, options) {\n    return resolveTypeDependencyFrom(src, raw, options).catch(function () { return extend(exports.DEFAULT_DEPENDENCY); });\n}\nfunction resolveTypeDependencyMap(src, dependencies, options) {\n    var cwd = path_1.dirname(src);\n    var keys = Object.keys(dependencies);\n    return Promise.all(keys.map(function (name) {\n        var resolveOptions = extend(options, { name: name, cwd: cwd, dev: false, global: false, peer: false });\n        return resolveDependency(parse_1.parseDependency(dependencies[name]), resolveOptions);\n    }))\n        .then(function (results) { return zipObject(keys, results); });\n}\nfunction resolveJspmDependency(pkgName, raw, options) {\n    return find_1.findUp(options.cwd, 'package.json')\n        .then(function (packageJsonPath) {\n        return jspm_config_1.resolve(pkgName, { cwd: path_1.dirname(packageJsonPath) });\n    })\n        .then(function (jspmConfig) {\n        return resolveJspmDependencyFrom(pkgName, raw, extend(options, { jspmConfig: jspmConfig }));\n    }, function (error) {\n        if (error instanceof jspm_config_1.ModuleNotFoundError) {\n            return resolveJspmDependencyFrom(pkgName, raw, options);\n        }\n        return Promise.reject(resolveError(raw, error, options));\n    });\n}\nexports.resolveJspmDependency = resolveJspmDependency;\nfunction resolveJspmDependencyFrom(name, raw, options) {\n    var parent = options.parent, jspmConfig = options.jspmConfig;\n    var modulePath = jspmConfig.path;\n    var src = path_1.resolve(options.cwd, modulePath, 'package.json');\n    checkCircularDependency(parent, src);\n    options.emitter.emit('resolve', { name: name, src: src, raw: raw, parent: parent });\n    return fs_1.readJson(src)\n        .catch(function (err) {\n        if (err.code === 'ENOENT') {\n            return;\n        }\n        return Promise.reject(err);\n    })\n        .then(function (meta) {\n        if (meta === void 0) { meta = {}; }\n        var tree = extend(exports.DEFAULT_DEPENDENCY, {\n            src: src,\n            raw: raw,\n            parent: parent,\n            name: meta.name,\n            version: meta.version,\n            main: meta.main,\n            browser: meta.browser,\n            typings: meta.typings,\n            browserTypings: meta.browserTypings\n        });\n        options.emitter.emit('resolved', { name: name, src: src, tree: tree, raw: raw, parent: parent });\n        var dependencyOptions = extend(options, { parent: tree });\n        var configPath = path_1.resolve(options.cwd, modulePath, config_1.CONFIG_FILE);\n        return Promise.all([\n            resolveJspmDependencyMap(jspmConfig.map, dependencyOptions),\n            maybeResolveTypeDependencyFrom(configPath, raw, options)\n        ])\n            .then(function (_a) {\n            var dependencies = _a[0], typedPackage = _a[1];\n            tree.dependencies = dependencies;\n            return mergeDependencies(tree, typedPackage);\n        });\n    });\n}\nfunction resolveJspmDependencyMap(dependencies, options) {\n    if (dependencies === void 0) { dependencies = {}; }\n    var keys = Object.keys(dependencies);\n    return Promise.all(keys.map(function (name) {\n        var resolveOptions = extend(options, { dev: false, peer: false, global: false, jspmConfig: dependencies[name] });\n        return resolveJspmDependencyFrom(name, \"jspm:\" + name, resolveOptions);\n    }))\n        .then(function (results) { return zipObject(keys, results); });\n}\nfunction checkCircularDependency(tree, filename) {\n    if (tree) {\n        var currentSrc = tree.src;\n        while (tree) {\n            invariant(tree.src !== filename, \"Circular dependency detected using \\\"\" + currentSrc + \"\\\"\");\n            tree = tree.parent;\n        }\n    }\n}\nfunction resolveError(raw, cause, options) {\n    var name = options.name;\n    var message = \"Unable to resolve \" + (raw == null ? 'typings' : \"\\\"\" + raw + \"\\\"\");\n    if (name != null) {\n        message += \" from \\\"\" + name + \"\\\"\";\n    }\n    return new error_1.default(message, cause);\n}\nfunction mergeDependencies(root) {\n    var trees = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        trees[_i - 1] = arguments[_i];\n    }\n    var dependency = extend(root);\n    for (var _a = 0, trees_1 = trees; _a < trees_1.length; _a++) {\n        var tree = trees_1[_a];\n        if (tree == null) {\n            continue;\n        }\n        var name = tree.name, raw = tree.raw, src = tree.src, main = tree.main, browser = tree.browser, typings = tree.typings, browserTypings = tree.browserTypings, parent = tree.parent, files = tree.files, global_1 = tree.global;\n        if (parent != null) {\n            dependency.parent = parent;\n        }\n        if (global_1 != null) {\n            dependency.global = global_1;\n        }\n        if (typeof name === 'string') {\n            dependency.name = name;\n        }\n        if (typeof raw === 'string') {\n            dependency.raw = raw;\n        }\n        if (main != null || browser != null || typings != null || browserTypings != null || files != null) {\n            dependency.src = src;\n            dependency.main = main;\n            dependency.files = files;\n            dependency.browser = browser;\n            dependency.typings = typings;\n            dependency.browserTypings = browserTypings;\n        }\n        dependency.postmessage = tree.postmessage || dependency.postmessage;\n        dependency.dependencies = extend(dependency.dependencies, tree.dependencies);\n        dependency.devDependencies = extend(dependency.devDependencies, tree.devDependencies);\n        dependency.peerDependencies = extend(dependency.peerDependencies, tree.peerDependencies);\n        dependency.globalDependencies = extend(dependency.globalDependencies, tree.globalDependencies);\n        dependency.globalDevDependencies = extend(dependency.globalDevDependencies, tree.globalDevDependencies);\n    }\n    return dependency;\n}\n//# sourceMappingURL=dependencies.js.map","/home/travis/build/npmtest/node-npmtest-typings/node_modules/typings-core/dist/utils/fs.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar fs = require(\"graceful-fs\");\nvar extend = require(\"xtend\");\nvar thenify = require(\"thenify\");\nvar stripBom = require(\"strip-bom\");\nvar parse = require(\"parse-json\");\nvar popsicle = require(\"popsicle\");\nvar popsicleStatus = require(\"popsicle-status\");\nvar popsicleRetry = require(\"popsicle-retry\");\nvar popsicleRewrite = require(\"popsicle-rewrite\");\nvar detectIndent = require(\"detect-indent\");\nvar sortKeys = require(\"sort-keys\");\nvar Mkdirp = require(\"mkdirp\");\nvar uniq = require(\"array-uniq\");\nvar lockfile = require(\"lockfile\");\nvar Rimraf = require(\"rimraf\");\nvar createProxy = require(\"popsicle-proxy-agent\");\nvar Throat = require(\"throat\");\nvar promise_finally_1 = require(\"promise-finally\");\nvar Touch = require(\"touch\");\nvar path_1 = require(\"path\");\nvar url_1 = require(\"url\");\nvar template = require(\"string-template\");\nvar config_1 = require(\"./config\");\nvar path_2 = require(\"./path\");\nvar references_1 = require(\"./references\");\nvar rc_1 = require(\"./rc\");\nvar store_1 = require(\"./store\");\nvar debug_1 = require(\"./debug\");\nvar pkg = require('../../package.json');\nvar registryURL = url_1.parse(rc_1.default.registryURL);\nvar throat = Throat(Promise);\nexports.touch = throat(10, thenify(Touch));\nexports.stat = throat(10, thenify(fs.stat));\nexports.readFile = throat(10, thenify(fs.readFile));\nexports.writeFile = thenify(fs.writeFile);\nexports.mkdirp = throat(10, thenify(Mkdirp));\nexports.unlink = throat(10, thenify(fs.unlink));\nexports.lock = throat(10, thenify(lockfile.lock));\nexports.unlock = throat(10, thenify(lockfile.unlock));\nexports.rimraf = throat(10, thenify(Rimraf));\nexports.readdir = throat(10, thenify(fs.readdir));\nexports.rmdir = throat(10, thenify(fs.rmdir));\nfunction rmdirUntil(path, until) {\n    if (path === until) {\n        return Promise.resolve();\n    }\n    return exports.readdir(path)\n        .then(function (files) {\n        if (files.length) {\n            return;\n        }\n        return exports.rmdir(path)\n            .then(function () { return rmdirUntil(path_1.dirname(path), until); });\n    })\n        .catch(function (err) {\n        if (err.code === 'ENOENT') {\n            return;\n        }\n        return Promise.reject(err);\n    });\n}\nexports.rmdirUntil = rmdirUntil;\nfunction isFile(path) {\n    return exports.stat(path).then(function (stat) { return stat.isFile(); }, function () { return false; });\n}\nexports.isFile = isFile;\nfunction readJson(path, allowEmpty) {\n    return exports.readFile(path, 'utf8')\n        .then(stripBom)\n        .then(function (contents) { return parseJson(contents, path, allowEmpty); });\n}\nexports.readJson = readJson;\nfunction writeJson(path, json, indent, eol) {\n    return exports.writeFile(path, stringifyJson(json, indent, eol));\n}\nexports.writeJson = writeJson;\nfunction readConfig(path) {\n    return readJson(path, true).then(function (data) { return parseConfig(data, path); });\n}\nexports.readConfig = readConfig;\nfunction readConfigFrom(path) {\n    return readJsonFrom(path, true).then(function (data) { return parseConfig(data, path); });\n}\nexports.readConfigFrom = readConfigFrom;\nfunction parseConfig(config, path) {\n    return config;\n}\nexports.parseConfig = parseConfig;\nexports.proxy = createProxy({\n    proxy: rc_1.default.proxy,\n    httpProxy: rc_1.default.httpProxy,\n    httpsProxy: rc_1.default.httpsProxy,\n    noProxy: rc_1.default.noProxy\n});\nexports.readHttp = throat(5, function readHttp(url) {\n    var rejectUnauthorized = rc_1.default.rejectUnauthorized, ca = rc_1.default.ca, key = rc_1.default.key, cert = rc_1.default.cert, userAgent = rc_1.default.userAgent;\n    return popsicle.get({\n        url: url,\n        headers: {\n            'User-Agent': template(userAgent, {\n                nodeVersion: process.version,\n                platform: process.platform,\n                arch: process.arch,\n                typingsVersion: pkg.version\n            })\n        },\n        transport: popsicle.createTransport({\n            ca: ca,\n            key: key,\n            cert: cert,\n            agent: exports.proxy(url),\n            rejectUnauthorized: rejectUnauthorized\n        })\n    })\n        .use(popsicleStatus(200))\n        .use(popsicleRewrite(rc_1.default.urlRewrites || {}))\n        .use(function (request, next) {\n        if (request.Url.host === registryURL.host) {\n            if (store_1.default.get('clientId')) {\n                request.set('Typings-Client-Id', store_1.default.get('clientId'));\n            }\n            return next().then(function (response) {\n                if (response.get('Typings-Client-Id')) {\n                    store_1.default.set('clientId', response.get('Typings-Client-Id'));\n                }\n                return response;\n            });\n        }\n        return next();\n    })\n        .use(function (request, next) {\n        var hostname = request.Url.hostname;\n        if (rc_1.default.githubToken && (hostname === 'raw.githubusercontent.com' || hostname === 'api.github.com')) {\n            request.set('Authorization', \"token \" + rc_1.default.githubToken);\n        }\n        return next();\n    })\n        .use(popsicleRetry())\n        .then(function (response) {\n        debug_1.default('http response', response.toJSON());\n        return response.body;\n    });\n});\nfunction readFileFrom(from) {\n    return path_2.isHttp(from) ? exports.readHttp(from) : exports.readFile(from, 'utf8');\n}\nexports.readFileFrom = readFileFrom;\nfunction readJsonFrom(from, allowEmpty) {\n    return readFileFrom(from)\n        .then(stripBom)\n        .then(function (contents) { return parseJson(contents, from, allowEmpty); });\n}\nexports.readJsonFrom = readJsonFrom;\nfunction stringifyJson(json, indent, eol) {\n    if (eol === void 0) { eol = path_2.EOL; }\n    return path_2.normalizeEOL(JSON.stringify(json, null, indent || 2), eol) + eol;\n}\nexports.stringifyJson = stringifyJson;\nfunction parseJson(contents, path, allowEmpty) {\n    if (contents === '' && allowEmpty) {\n        return {};\n    }\n    return parse(contents, null, path);\n}\nexports.parseJson = parseJson;\nfunction transformFile(path, transform) {\n    function handle(contents) {\n        return Promise.resolve(transform(contents))\n            .then(function (contents) { return exports.writeFile(path, contents); });\n    }\n    var lockfile = path + \".lock\";\n    var lockOptions = { wait: 250, retries: 25, stale: 60000 };\n    var result = exports.lock(lockfile, lockOptions)\n        .then(function () {\n        return exports.readFile(path, 'utf8');\n    })\n        .then(function (contents) { return handle(contents); }, function () { return handle(undefined); });\n    return promise_finally_1.default(result, function () { return exports.unlock(lockfile); });\n}\nexports.transformFile = transformFile;\nfunction transformJson(path, transform, allowEmpty) {\n    return transformFile(path, function (contents) {\n        var indent = contents ? detectIndent(contents).indent : undefined;\n        var json = contents ? parseJson(stripBom(contents), path, allowEmpty) : undefined;\n        var eol = contents ? path_2.detectEOL(contents) : undefined;\n        return Promise.resolve(transform(json))\n            .then(function (json) { return stringifyJson(json, indent, eol); });\n    });\n}\nexports.transformJson = transformJson;\nfunction transformConfig(cwd, transform) {\n    var path = path_1.join(cwd, config_1.CONFIG_FILE);\n    return transformJson(path, function (config) {\n        if (config === void 0) { config = {}; }\n        return Promise.resolve(transform(parseConfig(config, path)))\n            .then(function (config) {\n            if (config.dependencies) {\n                config.dependencies = sortKeys(config.dependencies);\n            }\n            if (config.peerDependencies) {\n                config.peerDependencies = sortKeys(config.peerDependencies);\n            }\n            if (config.devDependencies) {\n                config.devDependencies = sortKeys(config.devDependencies);\n            }\n            if (config.globalDependencies) {\n                config.globalDependencies = sortKeys(config.globalDependencies);\n            }\n            if (config.globalDevDependencies) {\n                config.globalDevDependencies = sortKeys(config.globalDevDependencies);\n            }\n            return config;\n        });\n    }, true);\n}\nexports.transformConfig = transformConfig;\nfunction transformDtsFile(path, transform) {\n    var cwd = path_1.dirname(path);\n    return transformFile(path, function (contents) {\n        var typings = references_1.parseReferences(contents, cwd);\n        return Promise.resolve(transform(typings))\n            .then(function (typings) { return references_1.stringifyReferences(uniq(typings).sort(), cwd); });\n    });\n}\nexports.transformDtsFile = transformDtsFile;\nfunction treeToJson(tree) {\n    return extend(tree, {\n        parent: undefined,\n        dependencies: dependenciesToJson(tree.dependencies),\n        devDependencies: dependenciesToJson(tree.devDependencies),\n        peerDependencies: dependenciesToJson(tree.peerDependencies),\n        globalDependencies: dependenciesToJson(tree.globalDependencies),\n        globalDevDependencies: dependenciesToJson(tree.globalDevDependencies)\n    });\n}\nexports.treeToJson = treeToJson;\nfunction dependenciesToJson(dependencies) {\n    var json = {};\n    var keys = Object.keys(dependencies);\n    if (keys.length === 0) {\n        return;\n    }\n    for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {\n        var key = keys_1[_i];\n        json[key] = treeToJson(dependencies[key]);\n    }\n    return json;\n}\nexports.dependenciesToJson = dependenciesToJson;\n//# sourceMappingURL=fs.js.map","/home/travis/build/npmtest/node-npmtest-typings/node_modules/typings-core/dist/utils/config.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PROJECT_NAME = 'typings';\nexports.PRETTY_PROJECT_NAME = 'Typings';\nexports.CONFIG_FILE = exports.PROJECT_NAME + \".json\";\nexports.DEFAULT_TYPINGS_DIR = exports.PROJECT_NAME;\nexports.HOMEPAGE = 'https://github.com/typings/typings';\nexports.ISSUES_HOMEPAGE = 'https://github.com/typings/typings/issues';\nexports.DEPENDENCY_SEPARATOR = '~';\nexports.REGISTRY_URL = 'https://api.typings.org';\n//# sourceMappingURL=config.js.map","/home/travis/build/npmtest/node-npmtest-typings/node_modules/typings-core/dist/utils/path.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar path_1 = require(\"path\");\nvar url_1 = require(\"url\");\nvar isAbsolute = require(\"is-absolute\");\nvar config_1 = require(\"./config\");\nexports.EOL = '\\n';\nfunction isHttp(url) {\n    return /^https?\\:\\/\\//i.test(url);\n}\nexports.isHttp = isHttp;\nfunction isDefinition(path) {\n    if (isHttp(path)) {\n        return isDefinition(url_1.parse(path).pathname);\n    }\n    return /\\.d\\.ts$/.test(path);\n}\nexports.isDefinition = isDefinition;\nfunction isModuleName(value) {\n    return !isHttp(value) && !isAbsolute(value) && value.charAt(0) !== '.';\n}\nexports.isModuleName = isModuleName;\nfunction normalizeSlashes(path) {\n    return path.replace(/\\\\/g, '/');\n}\nexports.normalizeSlashes = normalizeSlashes;\nfunction joinUrl(from, to) {\n    return from.replace(/\\/$/, '') + \"/\" + to.replace(/^\\//, '');\n}\nexports.joinUrl = joinUrl;\nfunction resolveFrom(from, to) {\n    if (isHttp(to)) {\n        return to;\n    }\n    if (isHttp(from)) {\n        var url = url_1.parse(from);\n        url.pathname = url_1.resolve(url.pathname, to);\n        return url_1.format(url);\n    }\n    return path_1.resolve(path_1.dirname(from), to);\n}\nexports.resolveFrom = resolveFrom;\nfunction relativeTo(from, to) {\n    if (isHttp(from)) {\n        var fromUrl = url_1.parse(from);\n        if (isHttp(to)) {\n            var toUrl = url_1.parse(to);\n            if (toUrl.auth !== fromUrl.auth || toUrl.host !== fromUrl.host) {\n                return to;\n            }\n            var relativeUrl = relativeTo(fromUrl.pathname, toUrl.pathname);\n            if (toUrl.search) {\n                relativeUrl += toUrl.search;\n            }\n            if (toUrl.hash) {\n                relativeUrl += toUrl.hash;\n            }\n            return relativeUrl;\n        }\n        return relativeTo(fromUrl.pathname, to);\n    }\n    return path_1.relative(path_1.dirname(from), to);\n}\nexports.relativeTo = relativeTo;\nfunction appendToPath(path, suffix) {\n    if (isHttp(path)) {\n        var url = url_1.parse(path);\n        url.pathname = appendToPath(url.pathname, suffix);\n        return url_1.format(url);\n    }\n    return path + path_1.normalize(suffix);\n}\nexports.appendToPath = appendToPath;\nfunction pathFromDefinition(path) {\n    if (isHttp(path)) {\n        return pathFromDefinition(url_1.parse(path).pathname);\n    }\n    return path.replace(/\\.d\\.ts$/, '');\n}\nexports.pathFromDefinition = pathFromDefinition;\nfunction normalizeToDefinition(path) {\n    if (isDefinition(path)) {\n        return path;\n    }\n    if (isHttp(path)) {\n        var url = url_1.parse(path);\n        url.pathname = normalizeToDefinition(path);\n        return url_1.format(url);\n    }\n    var ext = path_1.extname(path);\n    return appendToPath(ext ? path.slice(0, -ext.length) : path, '.d.ts');\n}\nexports.normalizeToDefinition = normalizeToDefinition;\nfunction getDefinitionPath(path) {\n    return path_1.join(path, 'index.d.ts');\n}\nexports.getDefinitionPath = getDefinitionPath;\nfunction getDependencyPath(options) {\n    var type = options.global ? 'globals' : 'modules';\n    var directory = path_1.join(options.path, type, options.name);\n    var definition = getDefinitionPath(directory);\n    var config = path_1.join(directory, 'typings.json');\n    return { directory: directory, definition: definition, config: config };\n}\nexports.getDependencyPath = getDependencyPath;\nfunction getInfoFromDependencyLocation(location, bundle) {\n    var parts = relativeTo(bundle, location).split(path_1.sep);\n    return {\n        location: location,\n        global: parts[0] === 'globals',\n        name: parts.slice(1, -1).join('/')\n    };\n}\nexports.getInfoFromDependencyLocation = getInfoFromDependencyLocation;\nfunction detectEOL(contents) {\n    var match = contents.match(/\\r\\n|\\r|\\n/);\n    return match ? match[0] : undefined;\n}\nexports.detectEOL = detectEOL;\nfunction normalizeEOL(contents, eol) {\n    return contents.replace(/\\r\\n|\\r|\\n/g, eol);\n}\nexports.normalizeEOL = normalizeEOL;\nfunction normalizeResolutions(resolutions, options) {\n    var resolutionMap = {};\n    if (typeof resolutions === 'object') {\n        for (var _i = 0, _a = Object.keys(resolutions); _i < _a.length; _i++) {\n            var type = _a[_i];\n            resolutionMap[type] = path_1.join(options.cwd, resolutions[type]);\n        }\n    }\n    else if (typeof resolutions === 'string') {\n        resolutionMap.main = path_1.join(options.cwd, resolutions);\n    }\n    else {\n        resolutionMap.main = path_1.join(options.cwd, config_1.DEFAULT_TYPINGS_DIR);\n    }\n    return resolutionMap;\n}\nexports.normalizeResolutions = normalizeResolutions;\n//# sourceMappingURL=path.js.map","/home/travis/build/npmtest/node-npmtest-typings/node_modules/typings-core/dist/utils/references.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar path_1 = require(\"path\");\nvar isAbsolute = require(\"is-absolute\");\nvar path_2 = require(\"./path\");\nexports.REFERENCE_REGEXP = /^\\/\\/\\/[ \\t]*<reference[ \\t]+path[ \\t]*=(\"|')(.*?)\\1.*?\\/>[ \\t]*\\r?\\n?/gm;\nfunction extractReferences(contents, cwd) {\n    var refs = [];\n    var m;\n    do {\n        m = exports.REFERENCE_REGEXP.exec(contents);\n        if (m == null) {\n            break;\n        }\n        refs.push({\n            start: m.index,\n            end: m.index + m[0].length,\n            path: path_1.resolve(cwd, m[2])\n        });\n    } while (m);\n    return refs;\n}\nexports.extractReferences = extractReferences;\nfunction parseReferences(contents, cwd) {\n    return extractReferences(contents, cwd).map(function (ref) { return path_1.resolve(cwd, ref.path); });\n}\nexports.parseReferences = parseReferences;\nfunction stringifyReferences(paths, cwd) {\n    return paths.map(function (path) { return toReference(path, cwd); }).join(path_2.EOL) + path_2.EOL;\n}\nexports.stringifyReferences = stringifyReferences;\nfunction toReference(path, cwd) {\n    return \"/// <reference path=\\\"\" + path_2.normalizeSlashes(isAbsolute(path) ? path_1.relative(cwd, path) : path_1.normalize(path)) + \"\\\" />\";\n}\nexports.toReference = toReference;\n//# sourceMappingURL=references.js.map","/home/travis/build/npmtest/node-npmtest-typings/node_modules/typings-core/dist/utils/rc.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rc = require(\"rc\");\nvar extend = require(\"xtend\");\nvar config_1 = require(\"./config\");\nexports.DEFAULTS = {\n    userAgent: config_1.PROJECT_NAME + \"/{typingsVersion} node/{nodeVersion} {platform} {arch}\",\n    registryURL: config_1.REGISTRY_URL,\n    defaultSource: 'npm'\n};\nexports.default = extend(exports.DEFAULTS, rc(config_1.PROJECT_NAME));\n//# sourceMappingURL=rc.js.map","/home/travis/build/npmtest/node-npmtest-typings/node_modules/typings-core/dist/utils/store.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ConfigStore = require(\"configstore\");\nvar config_1 = require(\"./config\");\nexports.default = new ConfigStore(config_1.PROJECT_NAME);\n//# sourceMappingURL=store.js.map","/home/travis/build/npmtest/node-npmtest-typings/node_modules/typings-core/dist/utils/debug.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar debug = require(\"debug\");\nvar config_1 = require(\"./config\");\nexports.default = debug(config_1.PROJECT_NAME);\n//# sourceMappingURL=debug.js.map","/home/travis/build/npmtest/node-npmtest-typings/node_modules/typings-core/dist/utils/parse.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar invariant = require(\"invariant\");\nvar url_1 = require(\"url\");\nvar path_1 = require(\"path\");\nvar config_1 = require(\"./config\");\nvar path_2 = require(\"./path\");\nvar rc_1 = require(\"./rc\");\nfunction gitFromPath(src) {\n    var index = src.indexOf('#');\n    var sha = index === -1 ? 'master' : src.substr(index + 1);\n    var segments = index === -1 ? src.split('/') : src.substr(0, index).split('/');\n    var org = segments.shift();\n    var repo = segments.shift();\n    var path = segments.join('/');\n    var name;\n    if (segments.length === 0) {\n        path = config_1.CONFIG_FILE;\n    }\n    else if (path_2.isDefinition(path)) {\n        name = path_1.basename(path_2.pathFromDefinition(path));\n    }\n    else if (segments[segments.length - 1] !== config_1.CONFIG_FILE) {\n        path += \"/\" + config_1.CONFIG_FILE;\n    }\n    return { org: org, repo: repo, path: path, sha: sha, name: name };\n}\nfunction splitProtocol(raw) {\n    var index = raw.indexOf(':');\n    if (index === -1) {\n        return [undefined, raw];\n    }\n    return [raw.substr(0, index), path_2.normalizeSlashes(raw.substr(index + 1))];\n}\nfunction parseDependency(raw) {\n    var _a = splitProtocol(raw), type = _a[0], src = _a[1];\n    if (type === 'file') {\n        var location = path_1.normalize(src);\n        var filename = path_1.basename(location);\n        var name = path_2.isDefinition(filename) ? path_2.pathFromDefinition(filename) : undefined;\n        invariant(filename === config_1.CONFIG_FILE || path_2.isDefinition(filename), \"Only \\\".d.ts\\\" and \\\"\" + config_1.CONFIG_FILE + \"\\\" files are supported\");\n        return {\n            raw: raw,\n            type: type,\n            meta: {\n                name: name,\n                path: location\n            },\n            location: location\n        };\n    }\n    if (type === 'github') {\n        var meta = gitFromPath(src);\n        var org = meta.org, repo = meta.repo, path = meta.path, sha = meta.sha;\n        var location = \"https://raw.githubusercontent.com/\" + org + \"/\" + repo + \"/\" + sha + \"/\" + path;\n        return {\n            raw: raw,\n            meta: meta,\n            type: type,\n            location: location\n        };\n    }\n    if (type === 'bitbucket') {\n        var meta = gitFromPath(src);\n        var org = meta.org, repo = meta.repo, path = meta.path, sha = meta.sha;\n        var location = \"https://bitbucket.org/\" + org + \"/\" + repo + \"/raw/\" + sha + \"/\" + path;\n        return {\n            raw: raw,\n            meta: meta,\n            type: type,\n            location: location\n        };\n    }\n    if (type === 'jspm') {\n        return {\n            raw: raw,\n            type: 'jspm',\n            location: src,\n            meta: {\n                name: src\n            }\n        };\n    }\n    if (type === 'npm') {\n        var parts = src.split('/');\n        var isScoped = parts.length > 0 && parts[0].charAt(0) === '@';\n        var hasPath = isScoped ? parts.length > 2 : parts.length > 1;\n        if (!hasPath) {\n            parts.push('package.json');\n        }\n        return {\n            raw: raw,\n            type: 'npm',\n            meta: {\n                name: isScoped ? parts.slice(0, 2).join('/') : parts[0],\n                path: path_1.join.apply(void 0, parts.slice(isScoped ? 2 : 1))\n            },\n            location: path_1.join.apply(void 0, parts)\n        };\n    }\n    if (type === 'bower') {\n        var parts = src.split('/');\n        if (parts.length === 1) {\n            parts.push('bower.json');\n        }\n        return {\n            raw: raw,\n            type: 'bower',\n            meta: {\n                name: parts[0],\n                path: path_1.join.apply(void 0, parts.slice(1))\n            },\n            location: path_1.join.apply(void 0, parts)\n        };\n    }\n    if (type === 'http' || type === 'https') {\n        return {\n            raw: raw,\n            type: type,\n            meta: {},\n            location: raw\n        };\n    }\n    if (type === 'registry') {\n        var parts = /^([^\\/]+)\\/(.+?)(?:@(.*?)|#(.*?))?$/.exec(src);\n        if (parts == null) {\n            throw new TypeError(\"Unable to parse: \" + raw);\n        }\n        var source = parts[1], name = parts[2], version = parts[3], tag = parts[4];\n        if (version != null && tag != null) {\n            throw new TypeError(\"Unable to use tag and version together: \" + raw);\n        }\n        var path = \"entries/\" + encodeURIComponent(source) + \"/\" + encodeURIComponent(name);\n        if (tag) {\n            path += \"/tags/\" + encodeURIComponent(tag);\n        }\n        else if (version) {\n            path += \"/versions/\" + encodeURIComponent(version) + \"/latest\";\n        }\n        else {\n            path += '/versions/latest';\n        }\n        return {\n            raw: raw,\n            type: type,\n            meta: {\n                source: source,\n                name: name,\n                version: version,\n                tag: tag\n            },\n            location: path_2.joinUrl(rc_1.default.registryURL, path)\n        };\n    }\n    throw new TypeError(\"Unknown dependency: \" + raw);\n}\nexports.parseDependency = parseDependency;\nfunction resolveDependency(raw, filename) {\n    var _a = parseDependency(raw), type = _a.type, meta = _a.meta, location = _a.location;\n    if (type === 'http' || type === 'https') {\n        return url_1.resolve(location, filename);\n    }\n    if (type === 'github' || type === 'bitbucket') {\n        var org = meta.org, repo = meta.repo, sha = meta.sha;\n        var path = path_1.join(path_1.dirname(meta.path), filename);\n        return buildDependencyExpression(type, { org: org, repo: repo, sha: sha, path: path });\n    }\n    if (type === 'npm' || type === 'bower') {\n        var name = meta.name;\n        var path = path_1.join(path_1.dirname(meta.path), filename);\n        return buildDependencyExpression(type, { name: name, path: path });\n    }\n    if (type === 'file') {\n        var path = path_1.join(location, filename);\n        return buildDependencyExpression(type, { path: path });\n    }\n    throw new TypeError(\"Unable to resolve dependency from \\\"\" + raw + \"\\\"\");\n}\nexports.resolveDependency = resolveDependency;\nfunction parseDependencyExpression(raw, options) {\n    var _a = /^(?:([^=!:#]+)=)?(?:([\\w]+\\:.+)|((?:[\\w]+\\~)?.+))$/.exec(raw), name = _a[1], scheme = _a[2], registry = _a[3];\n    return {\n        name: name || options.name,\n        location: scheme || expandRegistry(registry, options)\n    };\n}\nexports.parseDependencyExpression = parseDependencyExpression;\nfunction buildDependencyExpression(type, meta) {\n    if (type === 'github' || type === 'bitbucket') {\n        var org = meta.org, repo = meta.repo, sha = meta.sha;\n        var resolvedPath = path_2.normalizeSlashes(meta.path);\n        return type + \":\" + org + \"/\" + repo + \"/\" + resolvedPath + (sha === 'master' ? '' : '#' + sha);\n    }\n    if (type === 'npm' || type === 'bower') {\n        var path = meta.path;\n        var resolvedPath = path ? \"/\" + path_2.normalizeSlashes(path) : '';\n        return type + \":\" + meta.name + resolvedPath;\n    }\n    if (type === 'file') {\n        return \"file:\" + path_2.normalizeSlashes(meta.path);\n    }\n    throw new TypeError(\"Unable to expand dependency type: \\\"\" + type + \"\\\"\");\n}\nexports.buildDependencyExpression = buildDependencyExpression;\nfunction expandRegistry(raw, options) {\n    if (options === void 0) { options = {}; }\n    if (typeof raw !== 'string') {\n        throw new TypeError(\"Expected registry name to be a string, not \" + typeof raw);\n    }\n    var indexOf = raw.indexOf('~');\n    var source = options.source || rc_1.default.defaultSource;\n    var name;\n    if (indexOf === -1) {\n        name = raw;\n    }\n    else {\n        source = raw.substr(0, indexOf);\n        name = raw.substr(indexOf + 1);\n    }\n    return \"registry:\" + source + \"/\" + name;\n}\nexports.expandRegistry = expandRegistry;\n//# sourceMappingURL=parse.js.map","/home/travis/build/npmtest/node-npmtest-typings/node_modules/typings-core/dist/utils/find.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar path_1 = require(\"path\");\nvar fs_1 = require(\"../utils/fs\");\nvar config_1 = require(\"./config\");\nfunction findProject(dir) {\n    return findConfigFile(dir).then(path_1.dirname);\n}\nexports.findProject = findProject;\nfunction findConfigFile(dir) {\n    return findUp(dir, config_1.CONFIG_FILE);\n}\nexports.findConfigFile = findConfigFile;\nfunction findUp(dir, filename, from) {\n    if (from === void 0) { from = dir; }\n    var path = path_1.join(dir, filename);\n    return fs_1.isFile(path)\n        .then(function (exists) {\n        return exists ? path : findUpParent(dir, filename, from);\n    });\n}\nexports.findUp = findUp;\nfunction findUpParent(dir, filename, from) {\n    var parentDir = path_1.dirname(dir);\n    if (dir === parentDir) {\n        return Promise.reject(new Error(\"Unable to find \\\"\" + filename + \"\\\" from \\\"\" + from + \"\\\"\"));\n    }\n    return findUp(parentDir, filename, from);\n}\n//# sourceMappingURL=find.js.map","/home/travis/build/npmtest/node-npmtest-typings/node_modules/typings-core/dist/search.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = require(\"xtend\");\nvar pick = require(\"object.pick\");\nvar querystring_1 = require(\"querystring\");\nvar url_1 = require(\"url\");\nvar fs_1 = require(\"./utils/fs\");\nvar rc_1 = require(\"./utils/rc\");\nfunction tidyParams(params) {\n    var result = extend(params);\n    for (var _i = 0, _a = Object.keys(result); _i < _a.length; _i++) {\n        var key = _a[_i];\n        if (result[key] == null) {\n            delete result[key];\n        }\n    }\n    return result;\n}\nfunction search(options) {\n    if (options === void 0) { options = {}; }\n    var query = tidyParams(pick(options, [\n        'query',\n        'name',\n        'source',\n        'offset',\n        'limit',\n        'order',\n        'sort'\n    ]));\n    return fs_1.readJsonFrom(url_1.resolve(rc_1.default.registryURL, \"search?\" + querystring_1.stringify(query)));\n}\nexports.search = search;\n//# sourceMappingURL=search.js.map","/home/travis/build/npmtest/node-npmtest-typings/node_modules/typings-core/dist/lib/error.js":"\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar make_error_cause_1 = require(\"make-error-cause\");\nvar TypingsError = (function (_super) {\n    __extends(TypingsError, _super);\n    function TypingsError() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.name = 'TypingsError';\n        return _this;\n    }\n    return TypingsError;\n}(make_error_cause_1.BaseError));\nexports.default = TypingsError;\n//# sourceMappingURL=error.js.map","/home/travis/build/npmtest/node-npmtest-typings/node_modules/typings-core/dist/lib/compile.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ts = require(\"typescript\");\nvar extend = require(\"xtend\");\nvar has = require(\"has\");\nvar path_1 = require(\"path\");\nvar fs_1 = require(\"../utils/fs\");\nvar path_2 = require(\"../utils/path\");\nvar path_3 = require(\"../utils/path\");\nvar references_1 = require(\"../utils/references\");\nvar config_1 = require(\"../utils/config\");\nvar error_1 = require(\"./error\");\nfunction compile(tree, resolutions, options) {\n    var name = options.name, cwd = options.cwd, global = options.global;\n    var fileCache = {};\n    if (tree.global && !global) {\n        return Promise.reject(new error_1.default(\"Unable to compile \\\"\" + name + \"\\\", the typings are meant to be installed as \" +\n            \"global but attempted to be compiled as an external module\"));\n    }\n    for (var _i = 0, resolutions_1 = resolutions; _i < resolutions_1.length; _i++) {\n        var resolution = resolutions_1[_i];\n        if (resolution !== 'main' && resolution !== 'browser') {\n            return Promise.reject(new error_1.default(\"Unable to resolve using \\\"\" + resolution + \"\\\" setting\"));\n        }\n    }\n    return Promise.all(resolutions.map(function (resolution) {\n        var resolved = {};\n        var imported = {};\n        return compileDependencyTree(tree, extend(options, {\n            resolution: resolution,\n            fileCache: fileCache,\n            imported: imported,\n            resolved: resolved\n        }));\n    }))\n        .then(function (output) {\n        var results = {};\n        for (var i = 0; i < output.length; i++) {\n            results[resolutions[i]] = output[i];\n        }\n        return {\n            cwd: cwd,\n            name: name,\n            tree: tree,\n            global: global,\n            results: results\n        };\n    });\n}\nexports.compile = compile;\nfunction resolveImportFrom(from, to) {\n    return path_3.isModuleName(to) ? to : path_3.resolveFrom(from, to);\n}\nfunction resolveOverride(src, to, tree) {\n    if (typeof to === 'string') {\n        if (path_3.isModuleName(to)) {\n            var _a = getModuleNameParts(to, tree), moduleName = _a[0], modulePath = _a[1];\n            return modulePath ? path_3.normalizeToDefinition(to) : moduleName;\n        }\n        return path_3.resolveFrom(src, path_3.normalizeToDefinition(to));\n    }\n    return to ? src : undefined;\n}\nfunction getStringifyOptions(tree, options, parent) {\n    var overrides = {};\n    var isTypings = typeof tree.typings === 'string';\n    var main = isTypings ? tree.typings : tree.main;\n    var browser = isTypings ? tree.browserTypings : tree.browser;\n    if (options.resolution === 'browser' && browser) {\n        if (typeof browser === 'string') {\n            var mainDefinition = path_3.resolveFrom(tree.src, path_3.normalizeToDefinition(main));\n            var browserDefinition = path_3.resolveFrom(tree.src, path_3.normalizeToDefinition(browser));\n            overrides[mainDefinition] = browserDefinition;\n        }\n        else {\n            for (var _i = 0, _a = Object.keys(browser); _i < _a.length; _i++) {\n                var key = _a[_i];\n                var from = resolveOverride(tree.src, key, tree);\n                var to = resolveOverride(tree.src, browser[key], tree);\n                overrides[from] = to;\n            }\n        }\n    }\n    var referenced = {};\n    var dependencies = {};\n    var entry = main == null ? undefined : path_3.normalizeToDefinition(main);\n    var prefix = \"\" + (parent ? parent.prefix : '') + config_1.DEPENDENCY_SEPARATOR + options.name;\n    return extend(options, {\n        tree: tree,\n        entry: entry,\n        prefix: prefix,\n        overrides: overrides,\n        referenced: referenced,\n        dependencies: dependencies,\n        parent: parent\n    });\n}\nfunction compileDependencyTree(tree, options) {\n    var stringifyOptions = getStringifyOptions(tree, options, undefined);\n    var contents = [];\n    var name = options.name, global = options.global, resolution = options.resolution;\n    options.emitter.emit('compiledependency', { tree: tree, global: global, name: name, resolution: resolution });\n    if (Array.isArray(tree.files)) {\n        for (var _i = 0, _a = tree.files; _i < _a.length; _i++) {\n            var file = _a[_i];\n            contents.push(stringifyDependencyImport(path_3.resolveFrom(tree.src, file), DependencyImport.ALL_PATHS, false, stringifyOptions));\n        }\n    }\n    if (stringifyOptions.entry) {\n        contents.push(stringifyDependencyImport(path_3.resolveFrom(tree.src, stringifyOptions.entry), DependencyImport.ALL_PATHS, true, stringifyOptions));\n    }\n    if (contents.length === 0) {\n        contents.push(stringifyDependencyImport(path_3.resolveFrom(tree.src, 'index.d.ts'), DependencyImport.DEFAULT_ONLY, true, stringifyOptions));\n    }\n    return Promise.all(contents).then(function (out) { return out.join(path_2.EOL); });\n}\nfunction cachedReadFileFrom(path, options) {\n    if (!has(options.fileCache, path)) {\n        options.fileCache[path] = fs_1.readFileFrom(path);\n    }\n    return options.fileCache[path];\n}\nfunction cachedStringifyOptions(name, compileOptions, options) {\n    if (!has(options.dependencies, name)) {\n        var branch = options.tree.dependencies[name];\n        if (branch) {\n            options.dependencies[name] = getStringifyOptions(branch, compileOptions, options);\n        }\n        else {\n            options.dependencies[name] = null;\n        }\n    }\n    return options.dependencies[name];\n}\nfunction getPath(path, options) {\n    if (has(options.overrides, path)) {\n        return options.overrides[path];\n    }\n    return path;\n}\nvar DependencyImport;\n(function (DependencyImport) {\n    DependencyImport[DependencyImport[\"DEFAULT_ONLY\"] = 0] = \"DEFAULT_ONLY\";\n    DependencyImport[DependencyImport[\"SUFFIXES_ONLY\"] = 1] = \"SUFFIXES_ONLY\";\n    DependencyImport[DependencyImport[\"ALL_PATHS\"] = 2] = \"ALL_PATHS\";\n})(DependencyImport || (DependencyImport = {}));\nfunction getDependencyImportPaths(importPath, mode) {\n    var paths = [];\n    if (mode === DependencyImport.DEFAULT_ONLY || mode === DependencyImport.ALL_PATHS) {\n        paths.push(importPath);\n    }\n    if (mode === DependencyImport.SUFFIXES_ONLY || mode === DependencyImport.ALL_PATHS) {\n        paths.push(path_3.appendToPath(importPath, '.d.ts'), path_3.appendToPath(importPath, '/index.d.ts'));\n    }\n    return paths;\n}\nfunction readDependencyImport(importPath, mode, isEntry, stringifyOptions, parent) {\n    function attempt(cause, paths, index, isEntry, options) {\n        var cwd = options.cwd, tree = options.tree, resolution = options.resolution, fileCache = options.fileCache, resolved = options.resolved, imported = options.imported, emitter = options.emitter, meta = options.meta;\n        if (index >= paths.length) {\n            var authorPhrase = options.parent ? \"The author of \\\"\" + options.parent.name + \"\\\" needs to\" : 'You should';\n            var relativePath = path_3.isModuleName(importPath) ? importPath : path_3.relativeTo(options.tree.src, importPath);\n            if (isEntry) {\n                return Promise.reject(new error_1.default(\"Unable to read typings for \\\"\" + options.name + \"\\\". \" +\n                    (authorPhrase + \" check the entry paths in \\\"\" + path_1.basename(options.tree.src) + \"\\\" are up to date\"), cause));\n            }\n            return Promise.reject(new error_1.default(\"Unable to read \\\"\" + relativePath + \"\\\" from \\\"\" + options.name + \"\\\". \" +\n                (authorPhrase + \" validate all import paths are accurate (case sensitive and relative)\"), cause));\n        }\n        var path = getPath(paths[index], options);\n        if (path_3.isModuleName(path)) {\n            var _a = getModuleNameParts(path, tree), moduleName = _a[0], modulePath = _a[1];\n            var childOptions = cachedStringifyOptions(moduleName, {\n                cwd: cwd,\n                resolution: resolution,\n                fileCache: fileCache,\n                emitter: emitter,\n                imported: imported,\n                resolved: resolved,\n                name: moduleName,\n                global: false,\n                meta: meta\n            }, options);\n            if (!childOptions) {\n                stringifyOptions.resolved[getCachePath(importPath, stringifyOptions, false)] = path;\n                return Promise.resolve(null);\n            }\n            var paths_1 = getDependencyImportPaths(path_3.resolveFrom(childOptions.tree.src, modulePath || childOptions.entry || 'index.d.ts'), modulePath ? DependencyImport.SUFFIXES_ONLY : (childOptions.entry ? DependencyImport.ALL_PATHS : DependencyImport.DEFAULT_ONLY));\n            return attempt(null, paths_1, 0, true, childOptions);\n        }\n        var cached = has(options.imported, path);\n        if (!cached) {\n            options.imported[path] = fs_1.readFileFrom(path).then(function (contents) {\n                var fileInfo = ts.preProcessFile(contents);\n                var sourceFile = ts.createSourceFile(path, contents.replace(references_1.REFERENCE_REGEXP, ''), ts.ScriptTarget.Latest, true);\n                var modulePath = getCachePath(path, options, true);\n                var moduleInfo = { path: path, modulePath: modulePath, isEntry: isEntry, parent: parent, sourceFile: sourceFile, options: options, fileInfo: fileInfo };\n                return moduleInfo;\n            }, function (err) {\n                if (err.code === 'ENOENT' || err.code === 'ENOTDIR' || err.code === 'EISDIR' || err.code === 'EINVALIDSTATUS') {\n                    return attempt(err, paths, index + 1, isEntry, options);\n                }\n                return Promise.reject(err);\n            });\n        }\n        return options.imported[path].then(function (moduleInfo) {\n            if (moduleInfo) {\n                stringifyOptions.resolved[getCachePath(importPath, stringifyOptions, false)] = moduleInfo.modulePath;\n            }\n            return !cached ? moduleInfo : undefined;\n        });\n    }\n    return attempt(null, getDependencyImportPaths(importPath, mode), 0, isEntry, stringifyOptions);\n}\nfunction stringifyDependencyImport(importPath, mode, isEntry, options, parent) {\n    return readDependencyImport(importPath, mode, isEntry, options, parent)\n        .then(function (info) { return info ? stringifyDependencyPath(info) : undefined; });\n}\nfunction getCachePath(originalPath, options, strip) {\n    var path = strip ? path_3.pathFromDefinition(originalPath) : originalPath;\n    if (path_3.isModuleName(path)) {\n        return path_3.normalizeSlashes(\"\" + options.prefix + config_1.DEPENDENCY_SEPARATOR + path);\n    }\n    return path_3.normalizeSlashes(path_1.join(options.prefix, path_3.relativeTo(options.tree.src, path)));\n}\nfunction stringifyDependencyPath(moduleInfo) {\n    var path = moduleInfo.path, options = moduleInfo.options, sourceFile = moduleInfo.sourceFile, fileInfo = moduleInfo.fileInfo;\n    var tree = options.tree, global = options.global, resolution = options.resolution, name = options.name, prefix = options.prefix, emitter = options.emitter;\n    emitter.emit('compile', { name: name, prefix: prefix, path: path, tree: tree, resolution: resolution });\n    var importedFiles = fileInfo.importedFiles.map(function (x) { return resolveImportFrom(path, x.fileName); });\n    var referencedFiles = fileInfo.referencedFiles.map(function (x) { return path_3.resolveFrom(path, x.fileName); });\n    if (global) {\n        Object.keys(tree.dependencies).forEach(function (x) { return importedFiles.push(x); });\n    }\n    var imports = importedFiles.map(function (importedFile) {\n        var mode = path_3.isModuleName(importedFile) ? DependencyImport.DEFAULT_ONLY : DependencyImport.SUFFIXES_ONLY;\n        return stringifyDependencyImport(importedFile, mode, false, options, moduleInfo);\n    });\n    return Promise.all(imports).then(function (imports) {\n        var stringified = stringifyModuleFile(moduleInfo);\n        for (var _i = 0, referencedFiles_1 = referencedFiles; _i < referencedFiles_1.length; _i++) {\n            var reference = referencedFiles_1[_i];\n            emitter.emit('reference', { name: name, prefix: prefix, path: path, reference: reference, tree: tree, resolution: resolution });\n        }\n        var contents = imports.filter(function (x) { return x != null; }).concat(stringified).join(path_2.EOL);\n        emitter.emit('compiled', { name: name, prefix: prefix, path: path, tree: tree, resolution: resolution, contents: contents });\n        return contents;\n    });\n}\nfunction getModuleNameParts(name, tree) {\n    var parts = name.split(/[\\\\\\/]/g);\n    var len = parts.length;\n    while (len) {\n        len--;\n        var name_1 = parts.slice(0, len).join('/');\n        var path = parts.slice(len).join('/');\n        if (tree.dependencies[name_1]) {\n            return [name_1, path];\n        }\n    }\n    return [parts.join('/'), null];\n}\nfunction getImportPath(path, options) {\n    return options.resolved[getCachePath(path, options, false)];\n}\nfunction stringifyModuleFile(info) {\n    var options = info.options, modulePath = info.modulePath;\n    var tree = options.tree, name = options.name, prefix = options.prefix, parent = options.parent, cwd = options.cwd, global = options.global;\n    var source = path_3.isHttp(info.path) ? info.path : path_3.normalizeSlashes(path_1.relative(cwd, info.path));\n    var meta = options.meta ? \"// Generated by \" + config_1.PROJECT_NAME + path_2.EOL + \"// Source: \" + source + path_2.EOL : '';\n    if (global) {\n        if (ts.isExternalModule(info.sourceFile)) {\n            throw new error_1.default(\"Attempted to compile \\\"\" + name + \"\\\" as a global \" +\n                \"module, but it looks like an external module. \" +\n                \"You'll need to remove the global option to continue.\");\n        }\n        return \"\" + meta + path_2.normalizeEOL(info.sourceFile.getText().trim(), path_2.EOL) + path_2.EOL;\n    }\n    else {\n        if (!ts.isExternalModule(info.sourceFile) && !(info.parent && ts.isExternalModule(info.parent.sourceFile))) {\n            throw new error_1.default(\"Attempted to compile \\\"\" + name + \"\\\" as an external module, \" +\n                \"but it looks like a global module. \" +\n                \"You'll need to enable the global option to continue.\");\n        }\n    }\n    var hasExports = false;\n    var hasDefaultExport = false;\n    var hasExportEquals = false;\n    var hasLocalImports = false;\n    var wasDeclared = false;\n    function replacer(node) {\n        if (node.kind === ts.SyntaxKind.ExportAssignment) {\n            hasDefaultExport = !node.isExportEquals;\n            hasExportEquals = !hasDefaultExport;\n        }\n        else if (node.kind === ts.SyntaxKind.ExportDeclaration) {\n            hasExports = true;\n        }\n        else if (node.kind === ts.SyntaxKind.ExportSpecifier) {\n            hasDefaultExport = hasDefaultExport || node.name.getText() === 'default';\n        }\n        var flags = ts.getCombinedModifierFlags(node);\n        hasExports = hasExports || !!(flags & ts.ModifierFlags.Export);\n        hasDefaultExport = hasDefaultExport || !!(flags & ts.ModifierFlags.Default);\n        if (node.kind === ts.SyntaxKind.StringLiteral &&\n            (node.parent.kind === ts.SyntaxKind.ExportDeclaration ||\n                node.parent.kind === ts.SyntaxKind.ImportDeclaration ||\n                node.parent.kind === ts.SyntaxKind.ModuleDeclaration)) {\n            hasLocalImports = hasLocalImports || !path_3.isModuleName(node.text);\n            return \" '\" + getImportPath(resolveImportFrom(info.path, node.text), options) + \"'\";\n        }\n        if (node.kind === ts.SyntaxKind.DeclareKeyword) {\n            wasDeclared = true;\n            return info.sourceFile.text.slice(node.getFullStart(), node.getStart());\n        }\n        if (node.kind === ts.SyntaxKind.ExternalModuleReference) {\n            var requirePath = getImportPath(resolveImportFrom(info.path, node.expression.text), options);\n            return \" require('\" + requirePath + \"')\";\n        }\n    }\n    function read(start, end) {\n        var text = info.sourceFile.text.slice(start, end);\n        if (start === 0) {\n            return text.replace(/^\\s+$/, '');\n        }\n        if (end == null) {\n            return text.replace(/\\s+$/, '');\n        }\n        if (wasDeclared) {\n            wasDeclared = false;\n            return text.replace(/^\\s+/, '');\n        }\n        return text;\n    }\n    var moduleText = path_2.normalizeEOL(processTree(info.sourceFile, replacer, read), path_2.EOL);\n    var moduleName = parent && parent.global ? name : modulePath;\n    if (info.isEntry && !hasLocalImports) {\n        return meta + declareText(parent ? moduleName : name, moduleText);\n    }\n    var prettyPath = path_3.normalizeSlashes(path_1.join(name, path_3.relativeTo(tree.src, path_3.pathFromDefinition(info.path))));\n    var declared = meta + declareText(modulePath, moduleText);\n    function alias(name) {\n        var imports = [];\n        if (hasExportEquals) {\n            imports.push(\"import main = require('\" + modulePath + \"');\");\n            imports.push(\"export = main;\");\n        }\n        else {\n            if (hasExports) {\n                imports.push(\"export * from '\" + modulePath + \"';\");\n            }\n            if (hasDefaultExport) {\n                imports.push(\"export { default } from '\" + modulePath + \"';\");\n            }\n        }\n        if (imports.length === 0) {\n            return '';\n        }\n        return declareText(name, imports.join(path_2.EOL));\n    }\n    if (info.isEntry && !parent) {\n        return declared + alias(prettyPath) + alias(name);\n    }\n    return declared + (parent ? '' : alias(prettyPath));\n}\nfunction declareText(name, text) {\n    return \"declare module '\" + name + \"' {\" + (text ? path_2.EOL + text + path_2.EOL : '') + \"}\" + path_2.EOL;\n}\nfunction processTree(sourceFile, replacer, reader) {\n    var code = '';\n    var position = 0;\n    function skip(node) {\n        position = node.end;\n    }\n    function readThrough(node) {\n        if (node.pos > position) {\n            code += reader(position, node.pos);\n            position = node.pos;\n        }\n    }\n    function visit(node) {\n        readThrough(node);\n        var replacement = replacer(node);\n        if (replacement != null) {\n            code += replacement;\n            skip(node);\n        }\n        else {\n            ts.forEachChild(node, visit);\n        }\n    }\n    visit(sourceFile);\n    code += reader(position);\n    return code;\n}\n//# sourceMappingURL=compile.js.map","/home/travis/build/npmtest/node-npmtest-typings/node_modules/typings-core/dist/uninstall.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = require(\"xtend\");\nvar events_1 = require(\"events\");\nvar path_1 = require(\"path\");\nvar fs_1 = require(\"./utils/fs\");\nvar find_1 = require(\"./utils/find\");\nvar path_2 = require(\"./utils/path\");\nfunction uninstallDependency(name, options) {\n    return uninstallDependencies([name], options);\n}\nexports.uninstallDependency = uninstallDependency;\nfunction uninstallDependencies(names, options) {\n    var emitter = options.emitter || new events_1.EventEmitter();\n    return find_1.findConfigFile(options.cwd)\n        .then(function (configFile) {\n        var cwd = path_1.dirname(configFile);\n        return fs_1.readConfig(configFile)\n            .then(function (config) {\n            var resolutions = path_2.normalizeResolutions(config.resolution, options);\n            return extend(options, { resolutions: resolutions, cwd: cwd, emitter: emitter });\n        });\n    }, function () {\n        var resolutions = path_2.normalizeResolutions(undefined, options);\n        return extend(options, { emitter: emitter, resolutions: resolutions });\n    })\n        .then(function (options) {\n        return Promise.all(names.map(function (x) { return uninstallFrom(x, options); }))\n            .then(function () { return writeBundle(names, options); })\n            .then(function () { return writeToConfig(names, options); })\n            .then(function () { return options; });\n    });\n}\nexports.uninstallDependencies = uninstallDependencies;\nfunction uninstallFrom(name, options) {\n    var cwd = options.cwd, global = options.global, emitter = options.emitter, resolutions = options.resolutions;\n    return Promise.all(Object.keys(resolutions).map(function (type) {\n        var path = resolutions[type];\n        var _a = path_2.getDependencyPath({ path: path, name: name, global: global }), directory = _a.directory, definition = _a.definition, config = _a.config;\n        return fs_1.isFile(definition)\n            .then(function (exists) {\n            if (!exists) {\n                emitter.emit('enoent', { path: definition });\n                return;\n            }\n            return Promise.all([\n                fs_1.unlink(definition),\n                fs_1.unlink(config)\n            ])\n                .then(function () { return fs_1.rmdirUntil(directory, cwd); });\n        });\n    }));\n}\nfunction writeToConfig(names, options) {\n    if (options.save || options.saveDev || options.savePeer) {\n        return fs_1.transformConfig(options.cwd, function (config) {\n            for (var _i = 0, names_1 = names; _i < names_1.length; _i++) {\n                var name = names_1[_i];\n                if (options.save) {\n                    if (options.global) {\n                        if (config.globalDependencies && config.globalDependencies[name]) {\n                            delete config.globalDependencies[name];\n                        }\n                        else {\n                            return Promise.reject(new TypeError(\"Typings for \\\"\" + name + \"\\\" are not listed in global dependencies\"));\n                        }\n                    }\n                    else {\n                        if (config.dependencies && config.dependencies[name]) {\n                            delete config.dependencies[name];\n                        }\n                        else {\n                            return Promise.reject(new TypeError(\"Typings for \\\"\" + name + \"\\\" are not listed in dependencies\"));\n                        }\n                    }\n                }\n                if (options.saveDev) {\n                    if (options.global) {\n                        if (config.globalDevDependencies && config.globalDevDependencies[name]) {\n                            delete config.globalDevDependencies[name];\n                        }\n                        else {\n                            return Promise.reject(new TypeError(\"Typings for \\\"\" + name + \"\\\" are not listed in global dev dependencies\"));\n                        }\n                    }\n                    else {\n                        if (config.devDependencies && config.devDependencies[name]) {\n                            delete config.devDependencies[name];\n                        }\n                        else {\n                            return Promise.reject(new TypeError(\"Typings for \\\"\" + name + \"\\\" are not listed in dev dependencies\"));\n                        }\n                    }\n                }\n                if (options.savePeer) {\n                    if (config.peerDependencies && config.peerDependencies[name]) {\n                        delete config.peerDependencies[name];\n                    }\n                    else {\n                        return Promise.reject(new TypeError(\"Typings for \\\"\" + name + \"\\\" are not listed in peer dependencies\"));\n                    }\n                }\n            }\n            return config;\n        });\n    }\n}\nfunction writeBundle(names, options) {\n    var global = options.global, resolutions = options.resolutions;\n    return Promise.all(Object.keys(resolutions).map(function (type) {\n        var path = resolutions[type];\n        var bundle = path_2.getDefinitionPath(path);\n        var paths = names.map(function (name) { return path_2.getDependencyPath({ path: path, name: name, global: global }).definition; });\n        return fs_1.transformDtsFile(bundle, function (references) {\n            return references.filter(function (x) { return paths.indexOf(x) === -1; });\n        });\n    }));\n}\n//# sourceMappingURL=uninstall.js.map","/home/travis/build/npmtest/node-npmtest-typings/node_modules/typings-core/dist/init.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend = require(\"xtend\");\nvar path_1 = require(\"path\");\nvar fs_1 = require(\"./utils/fs\");\nvar config_1 = require(\"./utils/config\");\nvar TSD_JSON_FILE = 'tsd.json';\nvar DEFINITELYTYPED_REPO = 'DefinitelyTyped/DefinitelyTyped';\nvar OLD_DEFINITELYTYPED_REPO = 'borisyankov/DefinitelyTyped';\nvar DEFAULT_CONFIG = {\n    dependencies: {}\n};\nvar PACKAGE_FILES = [\n    'package.json',\n    'bower.json'\n];\nfunction upgradeTsdJson(tsdJson, config) {\n    var typingsJson = extend(config);\n    var repo = tsdJson.repo || DEFINITELYTYPED_REPO;\n    if (repo === OLD_DEFINITELYTYPED_REPO) {\n        repo = DEFINITELYTYPED_REPO;\n    }\n    if (tsdJson.installed) {\n        typingsJson.globalDependencies = {};\n        Object.keys(tsdJson.installed).forEach(function (path) {\n            var dependency = tsdJson.installed[path];\n            var name = path_1.basename(path, '.d.ts');\n            var location = \"github:\" + repo + \"/\" + path + \"#\" + dependency.commit;\n            typingsJson.globalDependencies[name] = location;\n        });\n    }\n    return typingsJson;\n}\nfunction upgrade(options, config) {\n    return fs_1.readJson(path_1.join(options.cwd, TSD_JSON_FILE)).then(function (tsdJson) { return upgradeTsdJson(tsdJson, config); });\n}\nfunction getProjectName(options) {\n    if (options.name) {\n        return Promise.resolve(options.name);\n    }\n    return PACKAGE_FILES.reduce(function (promise, packageFileName) {\n        return promise.then(function (name) {\n            if (name != null) {\n                return name;\n            }\n            return fs_1.readJson(path_1.join(options.cwd, packageFileName))\n                .then(function (packageJson) { return packageJson.name; }, function () { return undefined; });\n        });\n    }, Promise.resolve(undefined));\n}\nfunction init(options) {\n    var path = path_1.join(options.cwd, config_1.CONFIG_FILE);\n    var main = options.main, version = options.version;\n    return fs_1.isFile(path)\n        .then(function (exists) {\n        if (exists) {\n            return Promise.reject(new TypeError(\"A \" + config_1.CONFIG_FILE + \" file already exists\"));\n        }\n    })\n        .then(function () { return getProjectName(options); })\n        .then(function (name) {\n        if (options.upgrade) {\n            return upgrade(options, { name: name, main: main, version: version });\n        }\n        return extend({ name: name, main: main, version: version }, DEFAULT_CONFIG);\n    })\n        .then(function (config) {\n        return fs_1.writeJson(path, config, 2);\n    });\n}\nexports.init = init;\n//# sourceMappingURL=init.js.map","/home/travis/build/npmtest/node-npmtest-typings/node_modules/typings-core/dist/bundle.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar path_1 = require(\"path\");\nvar events_1 = require(\"events\");\nvar dependencies_1 = require(\"./lib/dependencies\");\nvar compile_1 = require(\"./lib/compile\");\nvar fs_1 = require(\"./utils/fs\");\nfunction bundle(options) {\n    var cwd = options.cwd, global = options.global, out = options.out;\n    var emitter = options.emitter || new events_1.EventEmitter();\n    var resolution = options.resolution || 'main';\n    if (out == null) {\n        return Promise.reject(new TypeError('Out file path is required for bundle'));\n    }\n    return dependencies_1.resolveAllDependencies({ cwd: cwd, dev: false, global: false, emitter: emitter })\n        .then(function (tree) {\n        var name = options.name || tree.name;\n        if (name == null) {\n            return Promise.reject(new TypeError('Unable to infer typings name from project. Use the `--name` flag to specify it manually'));\n        }\n        return compile_1.compile(tree, [resolution], { cwd: cwd, name: name, global: global, emitter: emitter, meta: true });\n    })\n        .then(function (output) {\n        var path = path_1.resolve(cwd, out);\n        return fs_1.mkdirp(path_1.dirname(path))\n            .then(function () {\n            return fs_1.writeFile(path, output.results[resolution]);\n        })\n            .then(function () { return ({ tree: output.tree }); });\n    });\n}\nexports.bundle = bundle;\n//# sourceMappingURL=bundle.js.map","/home/travis/build/npmtest/node-npmtest-typings/node_modules/typings-core/dist/list.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar events_1 = require(\"events\");\nvar dependencies_1 = require(\"./lib/dependencies\");\nfunction list(options) {\n    var cwd = options.cwd;\n    var dev = !options.production;\n    var emitter = options.emitter || new events_1.EventEmitter();\n    return dependencies_1.resolveTypeDependencies({ cwd: cwd, global: true, dev: dev, emitter: emitter });\n}\nexports.list = list;\n//# sourceMappingURL=list.js.map","/home/travis/build/npmtest/node-npmtest-typings/node_modules/typings-core/dist/open.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar parse_1 = require(\"./utils/parse\");\nfunction open(raw, options) {\n    if (options === void 0) { options = {}; }\n    var dependency = parse_1.parseDependency(raw);\n    return dependency.location;\n}\nexports.open = open;\n//# sourceMappingURL=open.js.map","/home/travis/build/npmtest/node-npmtest-typings/node_modules/typings-core/dist/view.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar path_1 = require(\"./utils/path\");\nvar fs_1 = require(\"./utils/fs\");\nvar parse_1 = require(\"./utils/parse\");\nvar rc_1 = require(\"./utils/rc\");\nfunction viewEntry(raw, options) {\n    return new Promise(function (resolve) {\n        var meta = parse_1.parseDependency(parse_1.expandRegistry(raw)).meta;\n        var path = \"entries/\" + encodeURIComponent(meta.source) + \"/\" + encodeURIComponent(meta.name);\n        return resolve(fs_1.readJsonFrom(path_1.joinUrl(rc_1.default.registryURL, path)));\n    });\n}\nexports.viewEntry = viewEntry;\nfunction viewVersions(raw, options) {\n    return new Promise(function (resolve) {\n        var meta = parse_1.parseDependency(parse_1.expandRegistry(raw)).meta;\n        var path = \"entries/\" + encodeURIComponent(meta.source) + \"/\" + encodeURIComponent(meta.name) + \"/versions\";\n        if (meta.version) {\n            path += \"/\" + encodeURIComponent(meta.version);\n        }\n        return resolve(fs_1.readJsonFrom(path_1.joinUrl(rc_1.default.registryURL, path)));\n    });\n}\nexports.viewVersions = viewVersions;\n//# sourceMappingURL=view.js.map","/home/travis/build/npmtest/node-npmtest-typings/node_modules/typings-core/dist/prune.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar path_1 = require(\"path\");\nvar extend = require(\"xtend\");\nvar events_1 = require(\"events\");\nvar find_1 = require(\"./utils/find\");\nvar fs_1 = require(\"./utils/fs\");\nvar path_2 = require(\"./utils/path\");\nfunction prune(options) {\n    var cwd = options.cwd, production = options.production;\n    var emitter = options.emitter || new events_1.EventEmitter();\n    return find_1.findConfigFile(cwd)\n        .then(function (path) {\n        var cwd = path_1.dirname(path);\n        return fs_1.readConfig(path)\n            .then(function (config) {\n            return transformBundles(config, { cwd: cwd, production: production, emitter: emitter });\n        });\n    });\n}\nexports.prune = prune;\nfunction transformBundles(config, options) {\n    var production = options.production;\n    var resolutions = path_2.normalizeResolutions(config.resolution, options);\n    var dependencies = extend(config.dependencies, config.peerDependencies, production ? {} : config.devDependencies);\n    var globalDependencies = extend(config.globalDependencies, production ? {} : config.globalDevDependencies);\n    return Promise.all(Object.keys(resolutions).map(function (type) {\n        return transformBundle(resolutions[type], type, dependencies, globalDependencies, options);\n    })).then(function () { return undefined; });\n}\nfunction transformBundle(path, resolution, dependencies, globalDependencies, options) {\n    var emitter = options.emitter;\n    var rmQueue = [];\n    var bundle = path_2.getDefinitionPath(path);\n    return fs_1.isFile(bundle)\n        .then(function (exists) {\n        if (!exists) {\n            return;\n        }\n        return fs_1.transformDtsFile(bundle, function (typings) {\n            var infos = typings.map(function (x) { return path_2.getInfoFromDependencyLocation(x, bundle); });\n            var validPaths = [];\n            for (var _i = 0, infos_1 = infos; _i < infos_1.length; _i++) {\n                var _a = infos_1[_i], name = _a.name, global_1 = _a.global, location = _a.location;\n                if (global_1) {\n                    if (!globalDependencies.hasOwnProperty(name)) {\n                        emitter.emit('prune', { name: name, global: global_1, resolution: resolution });\n                        rmQueue.push(rmDependency({ name: name, global: global_1, path: path, emitter: emitter }));\n                    }\n                    else {\n                        validPaths.push(location);\n                    }\n                }\n                else {\n                    if (!dependencies.hasOwnProperty(name)) {\n                        emitter.emit('prune', { name: name, global: global_1, resolution: resolution });\n                        rmQueue.push(rmDependency({ name: name, global: global_1, path: path, emitter: emitter }));\n                    }\n                    else {\n                        validPaths.push(location);\n                    }\n                }\n            }\n            return validPaths;\n        });\n    })\n        .then(function () { return Promise.all(rmQueue); })\n        .then(function () { return undefined; });\n}\nfunction rmDependency(options) {\n    var path = options.path, emitter = options.emitter;\n    var _a = path_2.getDependencyPath(options), directory = _a.directory, definition = _a.definition, config = _a.config;\n    function remove(path) {\n        return fs_1.isFile(path)\n            .then(function (exists) {\n            if (!exists) {\n                emitter.emit('enoent', { path: path });\n                return;\n            }\n            return fs_1.unlink(path);\n        });\n    }\n    return Promise.all([\n        remove(config),\n        remove(definition)\n    ])\n        .then(function () { return fs_1.rmdirUntil(directory, path); });\n}\nexports.rmDependency = rmDependency;\n//# sourceMappingURL=prune.js.map","/home/travis/build/npmtest/node-npmtest-typings/node_modules/typings/dist/bin-init.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar typings_core_1 = require(\"typings-core\");\nfunction help() {\n    return \"\\ntypings init\\n\\nOptions:\\n  [--upgrade]    Upgrade `tsd.json` to `typings.json`\\n\";\n}\nexports.help = help;\nfunction exec(args, options) {\n    var cwd = options.cwd, upgrade = options.upgrade;\n    return typings_core_1.init({ cwd: cwd, upgrade: upgrade });\n}\nexports.exec = exec;\n//# sourceMappingURL=bin-init.js.map","/home/travis/build/npmtest/node-npmtest-typings/node_modules/typings/dist/bin-uninstall.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar chalk = require(\"chalk\");\nvar typings_core_1 = require(\"typings-core\");\nvar cli_1 = require(\"./support/cli\");\nfunction help() {\n    return \"\\ntypings uninstall <name> [--save|--save-dev|--save-peer] [--global]\\n\\nOptions:\\n  [--save|-S]       Remove from \\\"dependencies\\\"\\n  [--save-dev|-D]   Remove from \\\"devDependencies\\\"\\n  [--save-peer|-P]  Remove from \\\"peerDependencies\\\"\\n  [--global|-G]     Remove from the global version of dependencies\\n    [-SG]           Remove from \\\"globalDependencies\\\"\\n    [-DG]           Remove from \\\"globalDevDependencies\\\"\\n\\nAliases: r, rm, remove, un\\n\";\n}\nexports.help = help;\nfunction exec(args, options) {\n    if (args.length === 0) {\n        cli_1.logError(help());\n        return;\n    }\n    return cli_1.spinner(typings_core_1.uninstallDependencies(args, options))\n        .then(function (result) {\n        Object.keys(result.resolutions).forEach(function (name) {\n            args.forEach(function (arg) {\n                console.log(\"- \" + arg + \" \" + chalk.grey(\"(\" + name + \")\"));\n            });\n        });\n    });\n}\nexports.exec = exec;\n//# sourceMappingURL=bin-uninstall.js.map","/home/travis/build/npmtest/node-npmtest-typings/node_modules/typings/dist/bin-install.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar listify = require(\"listify\");\nvar typings_core_1 = require(\"typings-core\");\nvar cli_1 = require(\"./support/cli\");\nfunction help() {\n    return \"\\ntypings install (with no arguments, in package directory)\\ntypings install [<name>=]<location>\\n\\n  <name>      Alternate name of the definition\\n  <location>  The location to read from (described below)\\n\\nValid Locations:\\n  [<source>~]<pkg>[@<version>][#<tag>]\\n  file:<path>\\n  github:<org>/<repo>[/<path>][#<commitish>]\\n  bitbucket:<org>/<repo>[/<path>][#<commitish>]\\n  npm:<pkg>[/<path>]\\n  bower:<pkg>[/<path>]\\n  jspm:<pkg> (for jspm@0.17+)\\n  http(s)://<host>/<path>\\n\\n  <source>    The registry mirror: \\\"npm\\\", \\\"bower\\\", \\\"env\\\", \\\"global\\\", \\\"lib\\\" or \\\"dt\\\"\\n              When not specified, `defaultSource` in `.typingsrc` will be used.\\n  <path>      Path to a `.d.ts` file or `typings.json`\\n  <host>      A domain name (with optional port)\\n  <version>   A semver range (E.g. \\\">=4.0\\\")\\n  <tag>       The specific tag of a registry entry\\n  <commitish> A git commit, tag or branch\\n\\nOptions:\\n  [--save|-S]       Persist to \\\"dependencies\\\"\\n  [--save-dev|-D]   Persist to \\\"devDependencies\\\"\\n  [--save-peer|-P]  Persist to \\\"peerDependencies\\\"\\n  [--global|-G]     Install and persist as a global definition\\n    [-SG]           Persist to \\\"globalDependencies\\\"\\n    [-DG]           Persist to \\\"globalDevDependencies\\\"\\n  [--production]    Install only production dependencies (omits dev dependencies) and\\n                    is implictly set when environment variable NODE_ENV=production\\n  [--no-production] Install production and dev dependencies (overrides environment\\n                    variable NODE_ENV=production)\\n\\nAliases: i, in\\n\";\n}\nexports.help = help;\nfunction exec(args, options) {\n    var emitter = options.emitter, unicode = options.unicode;\n    if (typeof options.ambient !== 'undefined') {\n        cli_1.logError('The \"ambient\" flag is deprecated. Please use \"global\" instead', 'deprecated');\n        return;\n    }\n    if (args.length === 0) {\n        return cli_1.spinner(typings_core_1.install(options))\n            .then(function (result) {\n            var name = result.name, tree = result.tree;\n            console.log(cli_1.archifyDependencyTree({ name: name, tree: tree, unicode: unicode }));\n        });\n    }\n    emitter.on('reference', function (_a) {\n        var reference = _a.reference, resolution = _a.resolution, name = _a.name;\n        cli_1.logInfo(\"Stripped reference \\\"\" + reference + \"\\\" during installation from \\\"\" + name + \"\\\" (\" + resolution + \")\", 'reference');\n    });\n    emitter.on('globaldependencies', function (_a) {\n        var name = _a.name, dependencies = _a.dependencies;\n        var deps = Object.keys(dependencies).map(function (x) { return JSON.stringify(x); });\n        if (deps.length) {\n            cli_1.logInfo(\"\\\"\" + name + \"\\\" lists global dependencies on \" + listify(deps) + \" that must be installed manually\", 'globaldependencies');\n        }\n    });\n    return cli_1.spinner(typings_core_1.installDependenciesRaw(args, options))\n        .then(function (results) {\n        for (var _i = 0, results_1 = results; _i < results_1.length; _i++) {\n            var result = results_1[_i];\n            var name = result.name, tree = result.tree;\n            console.log(cli_1.archifyDependencyTree({ name: name, tree: tree, unicode: unicode }));\n        }\n    });\n}\nexports.exec = exec;\n//# sourceMappingURL=bin-install.js.map","/home/travis/build/npmtest/node-npmtest-typings/node_modules/typings/dist/bin-list.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar cli_1 = require(\"./support/cli\");\nvar typings_core_1 = require(\"typings-core\");\nfunction help() {\n    return \"\\ntypings list\\n\\nOptions:\\n  [--production] List only production dependencies (omit dev dependencies)\\n\\nAliases: la, ll, ls\\n\";\n}\nexports.help = help;\nfunction exec(args, options) {\n    return cli_1.spinner(typings_core_1.list(options))\n        .then(function (tree) {\n        console.log(cli_1.archifyDependencyTree({ tree: tree, unicode: options.unicode }));\n    });\n}\nexports.exec = exec;\n//# sourceMappingURL=bin-list.js.map","/home/travis/build/npmtest/node-npmtest-typings/node_modules/typings/dist/bin-search.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar columnify = require(\"columnify\");\nvar typings_core_1 = require(\"typings-core\");\nvar cli_1 = require(\"./support/cli\");\nfunction help() {\n    return \"\\ntypings search [query]\\n\\nOptions:\\n  [--name] <name>     Search for definitions by exact name (E.g. only \\\"react\\\")\\n  [--source] <source> The registry mirror (E.g. \\\"npm\\\", \\\"bower\\\", \\\"env\\\", \\\"global\\\", \\\"dt\\\", ...)\\n  [--offset] <x>      Skip first \\\"x\\\" results (default: 0)\\n  [--limit] <x>       Limit to \\\"x\\\" results (default: 20, max: 100)\\n  [--order] <order>   Direction to sort results (default: \\\"asc\\\", enum: \\\"asc\\\" or \\\"desc\\\")\\n  [--sort] <column>   Order results by a column (E.g. \\\"versions\\\", \\\"name\\\", ...)\\n\";\n}\nexports.help = help;\nfunction exec(args, options) {\n    var query = args[0];\n    var name = options.name, source = options.source, offset = options.offset, limit = options.limit, order = options.order, sort = options.sort;\n    return cli_1.spinner(typings_core_1.search({ name: name, source: source, query: query, offset: offset, limit: limit, order: order, sort: sort }))\n        .then(function (_a) {\n        var results = _a.results, total = _a.total;\n        if (total === 0) {\n            console.log('No results found for search');\n            return;\n        }\n        console.log(\"Viewing \" + results.length + \" of \" + total);\n        console.log('');\n        console.log(columnify(results));\n    });\n}\nexports.exec = exec;\n//# sourceMappingURL=bin-search.js.map","/home/travis/build/npmtest/node-npmtest-typings/node_modules/typings/dist/bin-open.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar typings_core_1 = require(\"typings-core\");\nvar cli_1 = require(\"./support/cli\");\nfunction help() {\n    return \"\\ntypings open <location>\\n\\n  <location>  A known Typings location with scheme (see typings install -h)\\n\";\n}\nexports.help = help;\nfunction exec(args) {\n    if (args.length === 0) {\n        cli_1.logError(help());\n        return;\n    }\n    console.log(typings_core_1.open(args[0]));\n}\nexports.exec = exec;\n//# sourceMappingURL=bin-open.js.map","/home/travis/build/npmtest/node-npmtest-typings/node_modules/typings/dist/bin-view.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar columnify = require(\"columnify\");\nvar typings_core_1 = require(\"typings-core\");\nvar cli_1 = require(\"./support/cli\");\nfunction help() {\n    return \"\\ntypings view <pkg>\\n\\n  <pkg>  A registry expression like `[<source>~]<pkg>`\\n\\nOptions:\\n  [--versions]  List all package versions\\n\\nAliases: info\\n\";\n}\nexports.help = help;\nfunction exec(args, options) {\n    if (args.length === 0) {\n        cli_1.logError(help());\n        return;\n    }\n    if (options.versions) {\n        return typings_core_1.viewVersions(args[0], options)\n            .then(function (versions) { return console.log(columnify(versions)); });\n    }\n    return typings_core_1.viewEntry(args[0], options)\n        .then(function (entry) { return console.log(columnify(entry)); });\n}\nexports.exec = exec;\n//# sourceMappingURL=bin-view.js.map","/home/travis/build/npmtest/node-npmtest-typings/node_modules/typings/dist/bin-prune.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar typings_core_1 = require(\"typings-core\");\nvar cli_1 = require(\"./support/cli\");\nfunction help() {\n    return \"\\ntypings prune\\n\\nOptions:\\n  [--production] Also prune non-production dependencies\\n\";\n}\nexports.help = help;\nfunction exec(args, options) {\n    return cli_1.spinner(typings_core_1.prune(options));\n}\nexports.exec = exec;\n//# sourceMappingURL=bin-prune.js.map"}